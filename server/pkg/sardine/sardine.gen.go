// Package sardine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package sardine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for AllowListReason.
const (
	AllowListReasonApi       AllowListReason = "api"
	AllowListReasonDashboard AllowListReason = "dashboard"
)

// Defines values for AllowListScope.
const (
	AllowListScopeField       AllowListScope = "field"
	AllowListScopeTransaction AllowListScope = "transaction"
)

// Defines values for AllowListType.
const (
	AllowListTypeBankAccount   AllowListType = "bank_account"
	AllowListTypeCardHash      AllowListType = "card_hash"
	AllowListTypeCardId        AllowListType = "card_id"
	AllowListTypeDan           AllowListType = "dan"
	AllowListTypeDeviceId      AllowListType = "device_id"
	AllowListTypeDeviceIp      AllowListType = "device_ip"
	AllowListTypeEmail         AllowListType = "email"
	AllowListTypeEmailDomain   AllowListType = "email_domain"
	AllowListTypeIdDoc         AllowListType = "id_doc"
	AllowListTypePhone         AllowListType = "phone"
	AllowListTypeTaxId         AllowListType = "tax_id"
	AllowListTypeUserId        AllowListType = "user_id"
	AllowListTypeWalletAddress AllowListType = "wallet_address"
)

// Defines values for AllowListWithoutClientIDandReasonScope.
const (
	AllowListWithoutClientIDandReasonScopeField       AllowListWithoutClientIDandReasonScope = "field"
	AllowListWithoutClientIDandReasonScopeTransaction AllowListWithoutClientIDandReasonScope = "transaction"
)

// Defines values for AllowListWithoutClientIDandReasonType.
const (
	AllowListWithoutClientIDandReasonTypeBankAccount   AllowListWithoutClientIDandReasonType = "bank_account"
	AllowListWithoutClientIDandReasonTypeCardHash      AllowListWithoutClientIDandReasonType = "card_hash"
	AllowListWithoutClientIDandReasonTypeCardId        AllowListWithoutClientIDandReasonType = "card_id"
	AllowListWithoutClientIDandReasonTypeDan           AllowListWithoutClientIDandReasonType = "dan"
	AllowListWithoutClientIDandReasonTypeDeviceId      AllowListWithoutClientIDandReasonType = "device_id"
	AllowListWithoutClientIDandReasonTypeDeviceIp      AllowListWithoutClientIDandReasonType = "device_ip"
	AllowListWithoutClientIDandReasonTypeEmail         AllowListWithoutClientIDandReasonType = "email"
	AllowListWithoutClientIDandReasonTypeEmailDomain   AllowListWithoutClientIDandReasonType = "email_domain"
	AllowListWithoutClientIDandReasonTypeIdDoc         AllowListWithoutClientIDandReasonType = "id_doc"
	AllowListWithoutClientIDandReasonTypePhone         AllowListWithoutClientIDandReasonType = "phone"
	AllowListWithoutClientIDandReasonTypeTaxId         AllowListWithoutClientIDandReasonType = "tax_id"
	AllowListWithoutClientIDandReasonTypeUserId        AllowListWithoutClientIDandReasonType = "user_id"
	AllowListWithoutClientIDandReasonTypeWalletAddress AllowListWithoutClientIDandReasonType = "wallet_address"
)

// Defines values for BankAccountType.
const (
	BankAccountTypeChecking BankAccountType = "checking"
	BankAccountTypeOther    BankAccountType = "other"
	BankAccountTypeSaving   BankAccountType = "saving"
)

// Defines values for BizAmlEntitiesAdverseMediaLevel.
const (
	BizAmlEntitiesAdverseMediaLevelHigh   BizAmlEntitiesAdverseMediaLevel = "high"
	BizAmlEntitiesAdverseMediaLevelLow    BizAmlEntitiesAdverseMediaLevel = "low"
	BizAmlEntitiesAdverseMediaLevelMedium BizAmlEntitiesAdverseMediaLevel = "medium"
)

// Defines values for BizAmlEntitiesPepLevel.
const (
	BizAmlEntitiesPepLevelHigh   BizAmlEntitiesPepLevel = "high"
	BizAmlEntitiesPepLevelLow    BizAmlEntitiesPepLevel = "low"
	BizAmlEntitiesPepLevelMedium BizAmlEntitiesPepLevel = "medium"
)

// Defines values for BizAmlEntitiesRiskLevel.
const (
	BizAmlEntitiesRiskLevelHigh     BizAmlEntitiesRiskLevel = "high"
	BizAmlEntitiesRiskLevelLow      BizAmlEntitiesRiskLevel = "low"
	BizAmlEntitiesRiskLevelMedium   BizAmlEntitiesRiskLevel = "medium"
	BizAmlEntitiesRiskLevelUnknown  BizAmlEntitiesRiskLevel = "unknown"
	BizAmlEntitiesRiskLevelVeryHigh BizAmlEntitiesRiskLevel = "very_high"
)

// Defines values for BizAmlEntitiesSanctionLevel.
const (
	BizAmlEntitiesSanctionLevelHigh   BizAmlEntitiesSanctionLevel = "high"
	BizAmlEntitiesSanctionLevelLow    BizAmlEntitiesSanctionLevel = "low"
	BizAmlEntitiesSanctionLevelMedium BizAmlEntitiesSanctionLevel = "medium"
)

// Defines values for BizConfigAdvancedAmlScreeningMode.
const (
	BizConfigAdvancedAmlScreeningModeMonitoringOnly         BizConfigAdvancedAmlScreeningMode = "monitoring_only"
	BizConfigAdvancedAmlScreeningModeScreeningAndMonitoring BizConfigAdvancedAmlScreeningMode = "screening_and_monitoring"
	BizConfigAdvancedAmlScreeningModeScreeningOnly          BizConfigAdvancedAmlScreeningMode = "screening_only"
)

// Defines values for BizConfigCheckpoints.
const (
	BizConfigCheckpointsBusiness      BizConfigCheckpoints = "business"
	BizConfigCheckpointsBusinessScore BizConfigCheckpoints = "business_score"
)

// Defines values for BizConfigKybLevel.
const (
	BizConfigKybLevelDisable  BizConfigKybLevel = "disable"
	BizConfigKybLevelStandard BizConfigKybLevel = "standard"
	BizConfigKybLevelTinOnly  BizConfigKybLevel = "tin-only"
)

// Defines values for BizConfigGetResponseAdvancedAmlScreeningMode.
const (
	BizConfigGetResponseAdvancedAmlScreeningModeMonitoringOnly         BizConfigGetResponseAdvancedAmlScreeningMode = "monitoring_only"
	BizConfigGetResponseAdvancedAmlScreeningModeScreeningAndMonitoring BizConfigGetResponseAdvancedAmlScreeningMode = "screening_and_monitoring"
	BizConfigGetResponseAdvancedAmlScreeningModeScreeningOnly          BizConfigGetResponseAdvancedAmlScreeningMode = "screening_only"
)

// Defines values for BizConfigGetResponseKybLevel.
const (
	BizConfigGetResponseKybLevelDisable  BizConfigGetResponseKybLevel = "disable"
	BizConfigGetResponseKybLevelStandard BizConfigGetResponseKybLevel = "standard"
	BizConfigGetResponseKybLevelTinOnly  BizConfigGetResponseKybLevel = "tin-only"
)

// Defines values for BizCustomerProng.
const (
	Control   BizCustomerProng = "control"
	Ownership BizCustomerProng = "ownership"
)

// Defines values for BlockListReason.
const (
	BlockListReasonApi           BlockListReason = "api"
	BlockListReasonDashboard     BlockListReason = "dashboard"
	BlockListReasonFraudFeedback BlockListReason = "fraud_feedback"
	BlockListReasonManualReview  BlockListReason = "manual_review"
	BlockListReasonNsf           BlockListReason = "nsf"
)

// Defines values for BlockListScope.
const (
	BlockListScopeField       BlockListScope = "field"
	BlockListScopeTransaction BlockListScope = "transaction"
)

// Defines values for BlockListType.
const (
	BlockListTypeBankAccount   BlockListType = "bank_account"
	BlockListTypeCardHash      BlockListType = "card_hash"
	BlockListTypeCardId        BlockListType = "card_id"
	BlockListTypeDan           BlockListType = "dan"
	BlockListTypeDeviceId      BlockListType = "device_id"
	BlockListTypeDeviceIp      BlockListType = "device_ip"
	BlockListTypeEmail         BlockListType = "email"
	BlockListTypeEmailDomain   BlockListType = "email_domain"
	BlockListTypeIdDoc         BlockListType = "id_doc"
	BlockListTypePartnerId     BlockListType = "partner_id"
	BlockListTypePhone         BlockListType = "phone"
	BlockListTypeTaxId         BlockListType = "tax_id"
	BlockListTypeUserId        BlockListType = "user_id"
	BlockListTypeWalletAddress BlockListType = "wallet_address"
)

// Defines values for BlockListWithoutClientIDandReasonScope.
const (
	BlockListWithoutClientIDandReasonScopeField       BlockListWithoutClientIDandReasonScope = "field"
	BlockListWithoutClientIDandReasonScopeTransaction BlockListWithoutClientIDandReasonScope = "transaction"
)

// Defines values for BlockListWithoutClientIDandReasonType.
const (
	BlockListWithoutClientIDandReasonTypeBankAccount   BlockListWithoutClientIDandReasonType = "bank_account"
	BlockListWithoutClientIDandReasonTypeCardHash      BlockListWithoutClientIDandReasonType = "card_hash"
	BlockListWithoutClientIDandReasonTypeCardId        BlockListWithoutClientIDandReasonType = "card_id"
	BlockListWithoutClientIDandReasonTypeDan           BlockListWithoutClientIDandReasonType = "dan"
	BlockListWithoutClientIDandReasonTypeDeviceId      BlockListWithoutClientIDandReasonType = "device_id"
	BlockListWithoutClientIDandReasonTypeDeviceIp      BlockListWithoutClientIDandReasonType = "device_ip"
	BlockListWithoutClientIDandReasonTypeEmail         BlockListWithoutClientIDandReasonType = "email"
	BlockListWithoutClientIDandReasonTypeEmailDomain   BlockListWithoutClientIDandReasonType = "email_domain"
	BlockListWithoutClientIDandReasonTypeIdDoc         BlockListWithoutClientIDandReasonType = "id_doc"
	BlockListWithoutClientIDandReasonTypePhone         BlockListWithoutClientIDandReasonType = "phone"
	BlockListWithoutClientIDandReasonTypeTaxId         BlockListWithoutClientIDandReasonType = "tax_id"
	BlockListWithoutClientIDandReasonTypeUserId        BlockListWithoutClientIDandReasonType = "user_id"
	BlockListWithoutClientIDandReasonTypeWalletAddress BlockListWithoutClientIDandReasonType = "wallet_address"
)

// Defines values for BusinessCategories.
const (
	CryptoOnramp BusinessCategories = "cryptoOnramp"
	ECommerce    BusinessCategories = "eCommerce"
	NeoBank      BusinessCategories = "neoBank"
	NftCustomer  BusinessCategories = "nftCustomer"
)

// Defines values for BusinessTags.
const (
	EkycFailed      BusinessTags = "ekyc failed"
	QuestionableKYC BusinessTags = "questionable KYC"
)

// Defines values for ConfigAdverseMedia.
const (
	ConfigAdverseMediaDisabled ConfigAdverseMedia = "disabled"
	ConfigAdverseMediaEnabled  ConfigAdverseMedia = "enabled"
)

// Defines values for ConfigPep.
const (
	ConfigPepDisabled ConfigPep = "disabled"
	ConfigPepEnabled  ConfigPep = "enabled"
)

// Defines values for ConfigSanction.
const (
	Disabled ConfigSanction = "disabled"
	Enabled  ConfigSanction = "enabled"
)

// Defines values for CryptoNetwork.
const (
	Algorand          CryptoNetwork = "algorand"
	Arbitrum          CryptoNetwork = "arbitrum"
	AvalancheCChain   CryptoNetwork = "avalanche_c_chain"
	Binance           CryptoNetwork = "binance"
	BinanceSmartChain CryptoNetwork = "binance_smart_chain"
	Bitcoin           CryptoNetwork = "bitcoin"
	BitcoinCash       CryptoNetwork = "bitcoin_cash"
	Bytom             CryptoNetwork = "bytom"
	Cardano           CryptoNetwork = "cardano"
	Celo              CryptoNetwork = "celo"
	Cosmos            CryptoNetwork = "cosmos"
	Dash              CryptoNetwork = "dash"
	Dogecoin          CryptoNetwork = "dogecoin"
	Elastos           CryptoNetwork = "elastos"
	Elrond            CryptoNetwork = "elrond"
	Ethereum          CryptoNetwork = "ethereum"
	EthereumClassic   CryptoNetwork = "ethereum_classic"
	Filecoin          CryptoNetwork = "filecoin"
	Hedera            CryptoNetwork = "hedera"
	Icon              CryptoNetwork = "icon"
	Iost              CryptoNetwork = "iost"
	Iota              CryptoNetwork = "iota"
	Klaytn            CryptoNetwork = "klaytn"
	Lisk              CryptoNetwork = "lisk"
	Litecoin          CryptoNetwork = "litecoin"
	Monero            CryptoNetwork = "monero"
	Nebulas           CryptoNetwork = "nebulas"
	Neo               CryptoNetwork = "neo"
	Oasis             CryptoNetwork = "oasis"
	Omni              CryptoNetwork = "omni"
	Ontology          CryptoNetwork = "ontology"
	Optimism          CryptoNetwork = "optimism"
	Pai               CryptoNetwork = "pai"
	Polkadot          CryptoNetwork = "polkadot"
	Polygon           CryptoNetwork = "polygon"
	Qtum              CryptoNetwork = "qtum"
	Ripple            CryptoNetwork = "ripple"
	Solana            CryptoNetwork = "solana"
	Steem             CryptoNetwork = "steem"
	Stellar           CryptoNetwork = "stellar"
	Tezos             CryptoNetwork = "tezos"
	Tron              CryptoNetwork = "tron"
	Zcash             CryptoNetwork = "zcash"
	Zilliqa           CryptoNetwork = "zilliqa"
)

// Defines values for CustomerType.
const (
	CustomerTypeApplicant          CustomerType = "applicant"
	CustomerTypeBeneficialOwner    CustomerType = "beneficial_owner"
	CustomerTypeBusiness           CustomerType = "business"
	CustomerTypeCoapplicant        CustomerType = "coapplicant"
	CustomerTypeControllingOfficer CustomerType = "controlling_officer"
	CustomerTypeCourier            CustomerType = "courier"
	CustomerTypeCustomerDefault    CustomerType = "customer (default)"
	CustomerTypeDriver             CustomerType = "driver"
	CustomerTypeEmployee           CustomerType = "employee"
	CustomerTypeInstitutional      CustomerType = "institutional"
	CustomerTypeOwner              CustomerType = "owner"
	CustomerTypeRetail             CustomerType = "retail"
	CustomerTypeSoleProprietor     CustomerType = "sole_proprietor"
	CustomerTypeTenant             CustomerType = "tenant"
	CustomerTypeVendor             CustomerType = "vendor"
)

// Defines values for FeedbackDisputeStatus.
const (
	EndCustomerLost   FeedbackDisputeStatus = "end_customer_lost"
	EndCustomerWon    FeedbackDisputeStatus = "end_customer_won"
	EvidenceNeeded    FeedbackDisputeStatus = "evidence_needed"
	EvidenceSubmitted FeedbackDisputeStatus = "evidence_submitted"
)

// Defines values for FeedbackScope.
const (
	Session FeedbackScope = "session"
	User    FeedbackScope = "user"
)

// Defines values for FeedbackStatus.
const (
	FeedbackStatusApproved           FeedbackStatus = "approved"
	FeedbackStatusCanceled           FeedbackStatus = "canceled"
	FeedbackStatusChallenge          FeedbackStatus = "challenge"
	FeedbackStatusChargeback         FeedbackStatus = "chargeback"
	FeedbackStatusChargebackFinal    FeedbackStatus = "chargeback_final"
	FeedbackStatusChargebackReversal FeedbackStatus = "chargeback_reversal"
	FeedbackStatusDeclined           FeedbackStatus = "declined"
	FeedbackStatusFraud              FeedbackStatus = "fraud"
	FeedbackStatusIssuerDeclined     FeedbackStatus = "issuer_declined"
	FeedbackStatusMerchantDispute    FeedbackStatus = "merchant_dispute"
	FeedbackStatusNetworkDeclined    FeedbackStatus = "network_declined"
	FeedbackStatusPass               FeedbackStatus = "pass"
	FeedbackStatusPaymentError       FeedbackStatus = "payment_error"
	FeedbackStatusPrompt             FeedbackStatus = "prompt"
	FeedbackStatusRefund             FeedbackStatus = "refund"
	FeedbackStatusReject             FeedbackStatus = "reject"
	FeedbackStatusSettled            FeedbackStatus = "settled"
	FeedbackStatusTimeout            FeedbackStatus = "timeout"
	FeedbackStatusUnsure             FeedbackStatus = "unsure"
	FeedbackStatusVoided             FeedbackStatus = "voided"
)

// Defines values for FeedbackType.
const (
	FeedbackTypeAccountUpdate        FeedbackType = "account_update"
	FeedbackTypeAddressChange        FeedbackType = "address_change"
	FeedbackTypeAppPush              FeedbackType = "app_push"
	FeedbackTypeAuthenticatorOtp     FeedbackType = "authenticator_otp"
	FeedbackTypeAuthorization        FeedbackType = "authorization"
	FeedbackTypeCallConfirm          FeedbackType = "call_confirm"
	FeedbackTypeCallOtp              FeedbackType = "call_otp"
	FeedbackTypeCaptcha              FeedbackType = "captcha"
	FeedbackTypeCardIssuance         FeedbackType = "card_issuance"
	FeedbackTypeEmailChange          FeedbackType = "email_change"
	FeedbackTypeEmailLink            FeedbackType = "email_link"
	FeedbackTypeEmailOtp             FeedbackType = "email_otp"
	FeedbackTypeFaceId               FeedbackType = "face_id"
	FeedbackTypeFingerprint          FeedbackType = "fingerprint"
	FeedbackTypeIdDoc                FeedbackType = "id_doc"
	FeedbackTypeIdentityVerification FeedbackType = "identity_verification"
	FeedbackTypeKba                  FeedbackType = "kba"
	FeedbackTypeLivenessCheck        FeedbackType = "liveness_check"
	FeedbackTypeLogin                FeedbackType = "login"
	FeedbackTypeLogout               FeedbackType = "logout"
	FeedbackTypeManualReview         FeedbackType = "manual_review"
	FeedbackTypeMerchantDecision     FeedbackType = "merchant_decision"
	FeedbackTypeN2faUpdate           FeedbackType = "2fa_update"
	FeedbackTypeN3ds                 FeedbackType = "3ds"
	FeedbackTypeOffboarding          FeedbackType = "offboarding"
	FeedbackTypeOnboarding           FeedbackType = "onboarding"
	FeedbackTypeOther                FeedbackType = "other"
	FeedbackTypePasswordChange       FeedbackType = "password_change"
	FeedbackTypePasswordReset        FeedbackType = "password_reset"
	FeedbackTypePaymentMethodLink    FeedbackType = "payment_method_link"
	FeedbackTypePhoneChange          FeedbackType = "phone_change"
	FeedbackTypeSecurityKey          FeedbackType = "security_key"
	FeedbackTypeSettlement           FeedbackType = "settlement"
	FeedbackTypeSignup               FeedbackType = "signup"
	FeedbackTypeSmsConfirm           FeedbackType = "sms_confirm"
	FeedbackTypeSmsOtp               FeedbackType = "sms_otp"
)

// Defines values for FlowType.
const (
	FlowTypeAccountUpdate        FlowType = "account_update"
	FlowTypeAddressChange        FlowType = "address_change"
	FlowTypeEmailChange          FlowType = "email_change"
	FlowTypeIdentityVerification FlowType = "identity_verification"
	FlowTypeLogin                FlowType = "login"
	FlowTypeLogout               FlowType = "logout"
	FlowTypeN2faUpdate           FlowType = "2fa_update"
	FlowTypeOnboarding           FlowType = "onboarding"
	FlowTypeOther                FlowType = "other"
	FlowTypePasswordChange       FlowType = "password_change"
	FlowTypePasswordReset        FlowType = "password_reset"
	FlowTypePaymentMethodLink    FlowType = "payment_method_link"
	FlowTypePhoneChange          FlowType = "phone_change"
	FlowTypeSignup               FlowType = "signup"
	FlowTypeTransaction          FlowType = "transaction"
)

// Defines values for PaymentMethodType.
const (
	PaymentMethodTypeBank   PaymentMethodType = "bank"
	PaymentMethodTypeCard   PaymentMethodType = "card"
	PaymentMethodTypeCash   PaymentMethodType = "cash"
	PaymentMethodTypeCrypto PaymentMethodType = "crypto"
	PaymentMethodTypeOther  PaymentMethodType = "other"
	PaymentMethodTypeWallet PaymentMethodType = "wallet"
	PaymentMethodTypeWire   PaymentMethodType = "wire"
)

// Defines values for PersonalInfoSource.
const (
	PersonalInfoSourceBankVerification  PersonalInfoSource = "bank_verification"
	PersonalInfoSourceIdVerification    PersonalInfoSource = "id_verification"
	PersonalInfoSourceOnboarding        PersonalInfoSource = "onboarding"
	PersonalInfoSourcePayment           PersonalInfoSource = "payment"
	PersonalInfoSourcePhoneVerification PersonalInfoSource = "phone_verification"
)

// Defines values for PersonalInfoAndPaymentMethodSource.
const (
	PersonalInfoAndPaymentMethodSourceBankVerification  PersonalInfoAndPaymentMethodSource = "bank_verification"
	PersonalInfoAndPaymentMethodSourceIdVerification    PersonalInfoAndPaymentMethodSource = "id_verification"
	PersonalInfoAndPaymentMethodSourceOnboarding        PersonalInfoAndPaymentMethodSource = "onboarding"
	PersonalInfoAndPaymentMethodSourcePayment           PersonalInfoAndPaymentMethodSource = "payment"
	PersonalInfoAndPaymentMethodSourcePhoneVerification PersonalInfoAndPaymentMethodSource = "phone_verification"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchBillingAddress.
const (
	ResponsePaymentMethodCardIdentityMatchBillingAddressExactMatch      ResponsePaymentMethodCardIdentityMatchBillingAddress = "exact_match"
	ResponsePaymentMethodCardIdentityMatchBillingAddressMatchExceptCity ResponsePaymentMethodCardIdentityMatchBillingAddress = "match_except_city"
	ResponsePaymentMethodCardIdentityMatchBillingAddressNoMatch         ResponsePaymentMethodCardIdentityMatchBillingAddress = "no_match"
	ResponsePaymentMethodCardIdentityMatchBillingAddressUnknown         ResponsePaymentMethodCardIdentityMatchBillingAddress = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchDateOfBirth.
const (
	ResponsePaymentMethodCardIdentityMatchDateOfBirthExactMatch   ResponsePaymentMethodCardIdentityMatchDateOfBirth = "exact_match"
	ResponsePaymentMethodCardIdentityMatchDateOfBirthNoMatch      ResponsePaymentMethodCardIdentityMatchDateOfBirth = "no_match"
	ResponsePaymentMethodCardIdentityMatchDateOfBirthPartialMatch ResponsePaymentMethodCardIdentityMatchDateOfBirth = "partial_match"
	ResponsePaymentMethodCardIdentityMatchDateOfBirthUnknown      ResponsePaymentMethodCardIdentityMatchDateOfBirth = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchEmailAddress.
const (
	ResponsePaymentMethodCardIdentityMatchEmailAddressExactMatch   ResponsePaymentMethodCardIdentityMatchEmailAddress = "exact_match"
	ResponsePaymentMethodCardIdentityMatchEmailAddressNoMatch      ResponsePaymentMethodCardIdentityMatchEmailAddress = "no_match"
	ResponsePaymentMethodCardIdentityMatchEmailAddressPartialMatch ResponsePaymentMethodCardIdentityMatchEmailAddress = "partial_match"
	ResponsePaymentMethodCardIdentityMatchEmailAddressUnknown      ResponsePaymentMethodCardIdentityMatchEmailAddress = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchFullName.
const (
	ResponsePaymentMethodCardIdentityMatchFullNameExactMatch   ResponsePaymentMethodCardIdentityMatchFullName = "exact_match"
	ResponsePaymentMethodCardIdentityMatchFullNameNoMatch      ResponsePaymentMethodCardIdentityMatchFullName = "no_match"
	ResponsePaymentMethodCardIdentityMatchFullNamePartialMatch ResponsePaymentMethodCardIdentityMatchFullName = "partial_match"
	ResponsePaymentMethodCardIdentityMatchFullNameUnknown      ResponsePaymentMethodCardIdentityMatchFullName = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchPhone.
const (
	ResponsePaymentMethodCardIdentityMatchPhoneExactMatch   ResponsePaymentMethodCardIdentityMatchPhone = "exact_match"
	ResponsePaymentMethodCardIdentityMatchPhoneNoMatch      ResponsePaymentMethodCardIdentityMatchPhone = "no_match"
	ResponsePaymentMethodCardIdentityMatchPhonePartialMatch ResponsePaymentMethodCardIdentityMatchPhone = "partial_match"
	ResponsePaymentMethodCardIdentityMatchPhoneUnknown      ResponsePaymentMethodCardIdentityMatchPhone = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchPostalCode.
const (
	ResponsePaymentMethodCardIdentityMatchPostalCodeExactMatch   ResponsePaymentMethodCardIdentityMatchPostalCode = "exact_match"
	ResponsePaymentMethodCardIdentityMatchPostalCodeNoMatch      ResponsePaymentMethodCardIdentityMatchPostalCode = "no_match"
	ResponsePaymentMethodCardIdentityMatchPostalCodePartialMatch ResponsePaymentMethodCardIdentityMatchPostalCode = "partial_match"
	ResponsePaymentMethodCardIdentityMatchPostalCodeUnknown      ResponsePaymentMethodCardIdentityMatchPostalCode = "unknown"
)

// Defines values for ResponsePaymentMethodCardIdentityMatchShippingAddress.
const (
	ResponsePaymentMethodCardIdentityMatchShippingAddressExactMatch      ResponsePaymentMethodCardIdentityMatchShippingAddress = "exact_match"
	ResponsePaymentMethodCardIdentityMatchShippingAddressMatchExceptCity ResponsePaymentMethodCardIdentityMatchShippingAddress = "match_except_city"
	ResponsePaymentMethodCardIdentityMatchShippingAddressNoMatch         ResponsePaymentMethodCardIdentityMatchShippingAddress = "no_match"
	ResponsePaymentMethodCardIdentityMatchShippingAddressUnknown         ResponsePaymentMethodCardIdentityMatchShippingAddress = "unknown"
)

// Defines values for SourceMetadataStatus.
const (
	Active   SourceMetadataStatus = "active"
	Filed    SourceMetadataStatus = "filed"
	Inactive SourceMetadataStatus = "inactive"
)

// Defines values for SourceType.
const (
	Registration SourceType = "registration"
)

// Defines values for TagsType.
const (
	TagsTypeFloat  TagsType = "float"
	TagsTypeInt    TagsType = "int"
	TagsTypeLevel  TagsType = "level"
	TagsTypeScore  TagsType = "score"
	TagsTypeString TagsType = "string"
)

// Defines values for TransactionActionType.
const (
	TransactionActionTypeBuy           TransactionActionType = "buy"
	TransactionActionTypeDeposit       TransactionActionType = "deposit"
	TransactionActionTypeExchange      TransactionActionType = "exchange"
	TransactionActionTypeLoanFunding   TransactionActionType = "loanFunding"
	TransactionActionTypeLoanRepayment TransactionActionType = "loanRepayment"
	TransactionActionTypeMultiParty    TransactionActionType = "multiParty"
	TransactionActionTypeRefund        TransactionActionType = "refund"
	TransactionActionTypeSell          TransactionActionType = "sell"
	TransactionActionTypeTopup         TransactionActionType = "topup"
	TransactionActionTypeTransfer      TransactionActionType = "transfer"
	TransactionActionTypeWithdraw      TransactionActionType = "withdraw"
)

// Defines values for TransactionPromotionsCategory.
const (
	AutomaticCoupon TransactionPromotionsCategory = "automatic_coupon"
	CouponCode      TransactionPromotionsCategory = "coupon_code"
	EgiftCard       TransactionPromotionsCategory = "egift_card"
	StoreCredit     TransactionPromotionsCategory = "store_credit"
)

// Defines values for TransactionPromotionsType.
const (
	FixedAmount  TransactionPromotionsType = "fixed_amount"
	FreeShipping TransactionPromotionsType = "free_shipping"
	Percentage   TransactionPromotionsType = "percentage"
)

// Defines values for WalletType.
const (
	WalletTypeAmazonPay  WalletType = "amazon_pay"
	WalletTypeApplePay   WalletType = "apple_pay"
	WalletTypeCashApp    WalletType = "cash_app"
	WalletTypeGooglePay  WalletType = "google_pay"
	WalletTypeInternal   WalletType = "internal"
	WalletTypeOla        WalletType = "ola"
	WalletTypeOther      WalletType = "other"
	WalletTypePaypal     WalletType = "paypal"
	WalletTypePhonepe    WalletType = "phonepe"
	WalletTypeSamsungPay WalletType = "samsung_pay"
	WalletTypeUnknown    WalletType = "unknown"
	WalletTypeVenmo      WalletType = "venmo"
)

// Defines values for CheckpointDataResponseType.
const (
	CheckpointDataResponseTypeScore       CheckpointDataResponseType = "score"
	CheckpointDataResponseTypeWeightedMax CheckpointDataResponseType = "weighted_max"
	CheckpointDataResponseTypeWeightedSum CheckpointDataResponseType = "weighted_sum"
)

// Defines values for PlaidDataSyncJSONBodyScope.
const (
	Auth         PlaidDataSyncJSONBodyScope = "auth"
	Balance      PlaidDataSyncJSONBodyScope = "balance"
	Identity     PlaidDataSyncJSONBodyScope = "identity"
	Transactions PlaidDataSyncJSONBodyScope = "transactions"
)

// Defines values for PostAllowlistExpireJSONBodyType.
const (
	PostAllowlistExpireJSONBodyTypeBankAccount   PostAllowlistExpireJSONBodyType = "bank_account"
	PostAllowlistExpireJSONBodyTypeCardHash      PostAllowlistExpireJSONBodyType = "card_hash"
	PostAllowlistExpireJSONBodyTypeCardId        PostAllowlistExpireJSONBodyType = "card_id"
	PostAllowlistExpireJSONBodyTypeDan           PostAllowlistExpireJSONBodyType = "dan"
	PostAllowlistExpireJSONBodyTypeDeviceId      PostAllowlistExpireJSONBodyType = "device_id"
	PostAllowlistExpireJSONBodyTypeDeviceIp      PostAllowlistExpireJSONBodyType = "device_ip"
	PostAllowlistExpireJSONBodyTypeEmail         PostAllowlistExpireJSONBodyType = "email"
	PostAllowlistExpireJSONBodyTypeEmailDomain   PostAllowlistExpireJSONBodyType = "email_domain"
	PostAllowlistExpireJSONBodyTypeIdDoc         PostAllowlistExpireJSONBodyType = "id_doc"
	PostAllowlistExpireJSONBodyTypePhone         PostAllowlistExpireJSONBodyType = "phone"
	PostAllowlistExpireJSONBodyTypeTaxId         PostAllowlistExpireJSONBodyType = "tax_id"
	PostAllowlistExpireJSONBodyTypeUserId        PostAllowlistExpireJSONBodyType = "user_id"
	PostAllowlistExpireJSONBodyTypeWalletAddress PostAllowlistExpireJSONBodyType = "wallet_address"
)

// Defines values for PostAllowlistFindJSONBodyType.
const (
	PostAllowlistFindJSONBodyTypeBankAccount   PostAllowlistFindJSONBodyType = "bank_account"
	PostAllowlistFindJSONBodyTypeCardHash      PostAllowlistFindJSONBodyType = "card_hash"
	PostAllowlistFindJSONBodyTypeCardId        PostAllowlistFindJSONBodyType = "card_id"
	PostAllowlistFindJSONBodyTypeDan           PostAllowlistFindJSONBodyType = "dan"
	PostAllowlistFindJSONBodyTypeDeviceId      PostAllowlistFindJSONBodyType = "device_id"
	PostAllowlistFindJSONBodyTypeDeviceIp      PostAllowlistFindJSONBodyType = "device_ip"
	PostAllowlistFindJSONBodyTypeEmail         PostAllowlistFindJSONBodyType = "email"
	PostAllowlistFindJSONBodyTypeEmailDomain   PostAllowlistFindJSONBodyType = "email_domain"
	PostAllowlistFindJSONBodyTypeIdDoc         PostAllowlistFindJSONBodyType = "id_doc"
	PostAllowlistFindJSONBodyTypePhone         PostAllowlistFindJSONBodyType = "phone"
	PostAllowlistFindJSONBodyTypeTaxId         PostAllowlistFindJSONBodyType = "tax_id"
	PostAllowlistFindJSONBodyTypeUserId        PostAllowlistFindJSONBodyType = "user_id"
	PostAllowlistFindJSONBodyTypeWalletAddress PostAllowlistFindJSONBodyType = "wallet_address"
)

// Defines values for PostBlockListExpireJSONBodyType.
const (
	PostBlockListExpireJSONBodyTypeBankAccount   PostBlockListExpireJSONBodyType = "bank_account"
	PostBlockListExpireJSONBodyTypeCardHash      PostBlockListExpireJSONBodyType = "card_hash"
	PostBlockListExpireJSONBodyTypeCardId        PostBlockListExpireJSONBodyType = "card_id"
	PostBlockListExpireJSONBodyTypeDan           PostBlockListExpireJSONBodyType = "dan"
	PostBlockListExpireJSONBodyTypeDeviceId      PostBlockListExpireJSONBodyType = "device_id"
	PostBlockListExpireJSONBodyTypeDeviceIp      PostBlockListExpireJSONBodyType = "device_ip"
	PostBlockListExpireJSONBodyTypeEmail         PostBlockListExpireJSONBodyType = "email"
	PostBlockListExpireJSONBodyTypeEmailDomain   PostBlockListExpireJSONBodyType = "email_domain"
	PostBlockListExpireJSONBodyTypeIdDoc         PostBlockListExpireJSONBodyType = "id_doc"
	PostBlockListExpireJSONBodyTypePhone         PostBlockListExpireJSONBodyType = "phone"
	PostBlockListExpireJSONBodyTypeTaxId         PostBlockListExpireJSONBodyType = "tax_id"
	PostBlockListExpireJSONBodyTypeUserId        PostBlockListExpireJSONBodyType = "user_id"
	PostBlockListExpireJSONBodyTypeWalletAddress PostBlockListExpireJSONBodyType = "wallet_address"
)

// Defines values for PostSpecificBlockListJSONBodyType.
const (
	PostSpecificBlockListJSONBodyTypeBankAccount   PostSpecificBlockListJSONBodyType = "bank_account"
	PostSpecificBlockListJSONBodyTypeCardHash      PostSpecificBlockListJSONBodyType = "card_hash"
	PostSpecificBlockListJSONBodyTypeCardId        PostSpecificBlockListJSONBodyType = "card_id"
	PostSpecificBlockListJSONBodyTypeDan           PostSpecificBlockListJSONBodyType = "dan"
	PostSpecificBlockListJSONBodyTypeDeviceId      PostSpecificBlockListJSONBodyType = "device_id"
	PostSpecificBlockListJSONBodyTypeDeviceIp      PostSpecificBlockListJSONBodyType = "device_ip"
	PostSpecificBlockListJSONBodyTypeEmail         PostSpecificBlockListJSONBodyType = "email"
	PostSpecificBlockListJSONBodyTypeEmailDomain   PostSpecificBlockListJSONBodyType = "email_domain"
	PostSpecificBlockListJSONBodyTypeIdDoc         PostSpecificBlockListJSONBodyType = "id_doc"
	PostSpecificBlockListJSONBodyTypePhone         PostSpecificBlockListJSONBodyType = "phone"
	PostSpecificBlockListJSONBodyTypeTaxId         PostSpecificBlockListJSONBodyType = "tax_id"
	PostSpecificBlockListJSONBodyTypeUserId        PostSpecificBlockListJSONBodyType = "user_id"
	PostSpecificBlockListJSONBodyTypeWalletAddress PostSpecificBlockListJSONBodyType = "wallet_address"
)

// Defines values for UpdateBizJSONBodyStatus.
const (
	Approved UpdateBizJSONBodyStatus = "approved"
	InReview UpdateBizJSONBodyStatus = "in_review"
	Rejected UpdateBizJSONBodyStatus = "rejected"
)

// Defines values for NewCaseJSONBodyCaseStatus.
const (
	NewCaseJSONBodyCaseStatusClosed NewCaseJSONBodyCaseStatus = "closed"
	NewCaseJSONBodyCaseStatusOpen   NewCaseJSONBodyCaseStatus = "open"
)

// Defines values for UpdateCaseJSONBodyCaseStatus.
const (
	UpdateCaseJSONBodyCaseStatusClosed UpdateCaseJSONBodyCaseStatus = "closed"
	UpdateCaseJSONBodyCaseStatusOpen   UpdateCaseJSONBodyCaseStatus = "open"
)

// Defines values for UpdateCaseJSONBodyExtensionTimer.
const (
	False UpdateCaseJSONBodyExtensionTimer = "false"
	True  UpdateCaseJSONBodyExtensionTimer = "true"
)

// Defines values for PostCustomerInformationJSONBodyCheckpoints.
const (
	PostCustomerInformationJSONBodyCheckpointsAch        PostCustomerInformationJSONBodyCheckpoints = "ach"
	PostCustomerInformationJSONBodyCheckpointsAml        PostCustomerInformationJSONBodyCheckpoints = "aml"
	PostCustomerInformationJSONBodyCheckpointsAmlBank    PostCustomerInformationJSONBodyCheckpoints = "aml_bank"
	PostCustomerInformationJSONBodyCheckpointsAmlCrypto  PostCustomerInformationJSONBodyCheckpoints = "aml_crypto"
	PostCustomerInformationJSONBodyCheckpointsCustomer   PostCustomerInformationJSONBodyCheckpoints = "customer"
	PostCustomerInformationJSONBodyCheckpointsDevice     PostCustomerInformationJSONBodyCheckpoints = "device"
	PostCustomerInformationJSONBodyCheckpointsKyc        PostCustomerInformationJSONBodyCheckpoints = "kyc"
	PostCustomerInformationJSONBodyCheckpointsLogin      PostCustomerInformationJSONBodyCheckpoints = "login"
	PostCustomerInformationJSONBodyCheckpointsOnboarding PostCustomerInformationJSONBodyCheckpoints = "onboarding"
	PostCustomerInformationJSONBodyCheckpointsPayment    PostCustomerInformationJSONBodyCheckpoints = "payment"
	PostCustomerInformationJSONBodyCheckpointsWithdrawal PostCustomerInformationJSONBodyCheckpoints = "withdrawal"
)

// Defines values for PostCustomerInformationJSONBodyCounterpartySource.
const (
	PostCustomerInformationJSONBodyCounterpartySourceBankVerification  PostCustomerInformationJSONBodyCounterpartySource = "bank_verification"
	PostCustomerInformationJSONBodyCounterpartySourceIdVerification    PostCustomerInformationJSONBodyCounterpartySource = "id_verification"
	PostCustomerInformationJSONBodyCounterpartySourceOnboarding        PostCustomerInformationJSONBodyCounterpartySource = "onboarding"
	PostCustomerInformationJSONBodyCounterpartySourcePayment           PostCustomerInformationJSONBodyCounterpartySource = "payment"
	PostCustomerInformationJSONBodyCounterpartySourcePhoneVerification PostCustomerInformationJSONBodyCounterpartySource = "phone_verification"
)

// Defines values for PostCustomerInformationJSONBodyCounterpartyType.
const (
	PostCustomerInformationJSONBodyCounterpartyTypeAgent           PostCustomerInformationJSONBodyCounterpartyType = "agent"
	PostCustomerInformationJSONBodyCounterpartyTypeBusiness        PostCustomerInformationJSONBodyCounterpartyType = "business"
	PostCustomerInformationJSONBodyCounterpartyTypeCeo             PostCustomerInformationJSONBodyCounterpartyType = "ceo"
	PostCustomerInformationJSONBodyCounterpartyTypeCustomerDefault PostCustomerInformationJSONBodyCounterpartyType = "customer (default)"
	PostCustomerInformationJSONBodyCounterpartyTypeExecutive       PostCustomerInformationJSONBodyCounterpartyType = "executive"
	PostCustomerInformationJSONBodyCounterpartyTypeOwner           PostCustomerInformationJSONBodyCounterpartyType = "owner"
	PostCustomerInformationJSONBodyCounterpartyTypeSoleProprietor  PostCustomerInformationJSONBodyCounterpartyType = "sole_proprietor"
	PostCustomerInformationJSONBodyCounterpartyTypeTenant          PostCustomerInformationJSONBodyCounterpartyType = "tenant"
	PostCustomerInformationJSONBodyCounterpartyTypeVendor          PostCustomerInformationJSONBodyCounterpartyType = "vendor"
)

// Defines values for PostCustomerFeedbackJSONBodyKind.
const (
	PostCustomerFeedbackJSONBodyKindChallenge   PostCustomerFeedbackJSONBodyKind = "challenge"
	PostCustomerFeedbackJSONBodyKindFlow        PostCustomerFeedbackJSONBodyKind = "flow"
	PostCustomerFeedbackJSONBodyKindIssuing     PostCustomerFeedbackJSONBodyKind = "issuing"
	PostCustomerFeedbackJSONBodyKindReview      PostCustomerFeedbackJSONBodyKind = "review"
	PostCustomerFeedbackJSONBodyKindTransaction PostCustomerFeedbackJSONBodyKind = "transaction"
)

// Defines values for PostKycTokenJSONBodyProvider.
const (
	Au10tix PostKycTokenJSONBodyProvider = "au10tix"
	Incode  PostKycTokenJSONBodyProvider = "incode"
)

// Defines values for PostCardsAuthorizationsJSONBodyCardNetwork.
const (
	AmericanExpress PostCardsAuthorizationsJSONBodyCardNetwork = "american_express"
	Discover        PostCardsAuthorizationsJSONBodyCardNetwork = "discover"
	Jcb             PostCardsAuthorizationsJSONBodyCardNetwork = "jcb"
	Mastercard      PostCardsAuthorizationsJSONBodyCardNetwork = "mastercard"
	Other           PostCardsAuthorizationsJSONBodyCardNetwork = "other"
	Rupay           PostCardsAuthorizationsJSONBodyCardNetwork = "rupay"
	Unionpay        PostCardsAuthorizationsJSONBodyCardNetwork = "unionpay"
	Visa            PostCardsAuthorizationsJSONBodyCardNetwork = "visa"
)

// Defines values for PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType.
const (
	Email            PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType = "email"
	PhoneCall        PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType = "phone_call"
	PushNotification PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType = "push_notification"
	Sms              PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType = "sms"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard.
const (
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardCardNotPresent        PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard = "card_not_present"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardCardPresent           PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard = "card_present"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardPreAuthorizedPurchase PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard = "pre_authorized_purchase"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardUnspecified           PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard = "unspecified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder.
const (
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderCustomerNotPresent    PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "customer_not_present"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderCustomerPresent       PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "customer_present"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderDeferredBilling       PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "deferred_billing"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderInstallmentPayment    PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "installment_payment"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderMailOrder             PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "mail_order"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderPreAuthorizedPurchase PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "pre_authorized_purchase"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderRecurringPayment      PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "recurring_payment"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderTelephoneOrder        PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "telephone_order"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolderUnspecified           PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder = "unspecified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan.
const (
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanApplePay                  PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "apple_pay"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanChipFailureUsedManual     PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "chip_failure_used_manual"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanChipFailureUsedTrack      PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "chip_failure_used_track"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanContactless               PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "contactless"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanElectronic                PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "electronic"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanFromFile                  PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "from_file"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanFromOtherCardlessEntry    PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "from_other_cardless_entry"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanFromServer                PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "from_server"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanGooglePay                 PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "google_pay"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanIntegratedCircuitCard     PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "integrated_circuit_card"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanKeyEntered                PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "key_entered"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanMagneticStripeContactless PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "magnetic_stripe_contactless"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanMagneticStripeFull        PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "magnetic_stripe_full"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanManual                    PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "manual"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanOcr                       PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "ocr"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanQrOrBarcode               PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "qr_or_barcode"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanSamsungPay                PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "samsung_pay"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanToken                     PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "token"
	PostCardsAuthorizationsJSONBodyTransactionEntryInfoPanUnspecified               PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan = "unspecified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionStatus.
const (
	PostCardsAuthorizationsJSONBodyTransactionStatusAttempt   PostCardsAuthorizationsJSONBodyTransactionStatus = "attempt"
	PostCardsAuthorizationsJSONBodyTransactionStatusChallenge PostCardsAuthorizationsJSONBodyTransactionStatus = "challenge"
	PostCardsAuthorizationsJSONBodyTransactionStatusFailure   PostCardsAuthorizationsJSONBodyTransactionStatus = "failure"
	PostCardsAuthorizationsJSONBodyTransactionStatusPending   PostCardsAuthorizationsJSONBodyTransactionStatus = "pending"
	PostCardsAuthorizationsJSONBodyTransactionStatusSuccess   PostCardsAuthorizationsJSONBodyTransactionStatus = "success"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionTerminalOperator.
const (
	PostCardsAuthorizationsJSONBodyTransactionTerminalOperatorAdministrative       PostCardsAuthorizationsJSONBodyTransactionTerminalOperator = "administrative"
	PostCardsAuthorizationsJSONBodyTransactionTerminalOperatorCardAcceptorOperated PostCardsAuthorizationsJSONBodyTransactionTerminalOperator = "card_acceptor_operated"
	PostCardsAuthorizationsJSONBodyTransactionTerminalOperatorCustomerOperated     PostCardsAuthorizationsJSONBodyTransactionTerminalOperator = "customer_operated"
	PostCardsAuthorizationsJSONBodyTransactionTerminalOperatorUnspecified          PostCardsAuthorizationsJSONBodyTransactionTerminalOperator = "unspecified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionTerminalType.
const (
	AdministrativeTerminal   PostCardsAuthorizationsJSONBodyTransactionTerminalType = "administrative_terminal"
	Atm                      PostCardsAuthorizationsJSONBodyTransactionTerminalType = "atm"
	Authorization            PostCardsAuthorizationsJSONBodyTransactionTerminalType = "authorization"
	CouponMachine            PostCardsAuthorizationsJSONBodyTransactionTerminalType = "coupon_machine"
	DialTerminal             PostCardsAuthorizationsJSONBodyTransactionTerminalType = "dial_terminal"
	Ecr                      PostCardsAuthorizationsJSONBodyTransactionTerminalType = "ecr"
	ElectronicCommerce       PostCardsAuthorizationsJSONBodyTransactionTerminalType = "electronic_commerce"
	FranchiseTeller          PostCardsAuthorizationsJSONBodyTransactionTerminalType = "franchise_teller"
	FuelMachine              PostCardsAuthorizationsJSONBodyTransactionTerminalType = "fuel_machine"
	HomeTerminal             PostCardsAuthorizationsJSONBodyTransactionTerminalType = "home_terminal"
	InteractiveTelevision    PostCardsAuthorizationsJSONBodyTransactionTerminalType = "interactive_television"
	Ivr                      PostCardsAuthorizationsJSONBodyTransactionTerminalType = "ivr"
	MicrTerminal             PostCardsAuthorizationsJSONBodyTransactionTerminalType = "micr_terminal"
	OffPremise               PostCardsAuthorizationsJSONBodyTransactionTerminalType = "off_premise"
	Payment                  PostCardsAuthorizationsJSONBodyTransactionTerminalType = "payment"
	PersonalBanking          PostCardsAuthorizationsJSONBodyTransactionTerminalType = "personal_banking"
	PersonalDigitalAssistant PostCardsAuthorizationsJSONBodyTransactionTerminalType = "personal_digital_assistant"
	PointOfBankingTerminal   PostCardsAuthorizationsJSONBodyTransactionTerminalType = "point_of_banking_terminal"
	PosTerminal              PostCardsAuthorizationsJSONBodyTransactionTerminalType = "pos_terminal"
	PublicUtility            PostCardsAuthorizationsJSONBodyTransactionTerminalType = "public_utility"
	ScreenPhone              PostCardsAuthorizationsJSONBodyTransactionTerminalType = "screen_phone"
	ScripMachine             PostCardsAuthorizationsJSONBodyTransactionTerminalType = "scrip_machine"
	SelfService              PostCardsAuthorizationsJSONBodyTransactionTerminalType = "self_service"
	SmartPhone               PostCardsAuthorizationsJSONBodyTransactionTerminalType = "smart_phone"
	Teller                   PostCardsAuthorizationsJSONBodyTransactionTerminalType = "teller"
	TicketMachine            PostCardsAuthorizationsJSONBodyTransactionTerminalType = "ticket_machine"
	TravelersCheckMachine    PostCardsAuthorizationsJSONBodyTransactionTerminalType = "travelers_check_machine"
	Unspecified              PostCardsAuthorizationsJSONBodyTransactionTerminalType = "unspecified"
	Vending                  PostCardsAuthorizationsJSONBodyTransactionTerminalType = "vending"
	Vru                      PostCardsAuthorizationsJSONBodyTransactionTerminalType = "vru"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionType.
const (
	BalanceInquiry PostCardsAuthorizationsJSONBodyTransactionType = "balance_inquiry"
	Cash           PostCardsAuthorizationsJSONBodyTransactionType = "cash"
	Purchase       PostCardsAuthorizationsJSONBodyTransactionType = "purchase"
	Return         PostCardsAuthorizationsJSONBodyTransactionType = "return"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet.
const (
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreetError       PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet = "error"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreetMatch       PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet = "match"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreetNodata      PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet = "nodata"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreetNomatch     PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet = "nomatch"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreetNotVerified PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet = "not_verified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip.
const (
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsZipError       PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip = "error"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsZipMatch       PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip = "match"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsZipNodata      PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip = "nodata"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsZipNomatch     PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip = "nomatch"
	PostCardsAuthorizationsJSONBodyTransactionValidationAvsZipNotVerified PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip = "not_verified"
)

// Defines values for PostCardsAuthorizationsJSONBodyTransactionValidationCvv.
const (
	Error        PostCardsAuthorizationsJSONBodyTransactionValidationCvv = "error"
	Match        PostCardsAuthorizationsJSONBodyTransactionValidationCvv = "match"
	Nomatch      PostCardsAuthorizationsJSONBodyTransactionValidationCvv = "nomatch"
	NotSupported PostCardsAuthorizationsJSONBodyTransactionValidationCvv = "not_supported"
	NotVerified  PostCardsAuthorizationsJSONBodyTransactionValidationCvv = "not_verified"
)

// Defines values for V2DevicesJSONBodyCheckpoints.
const (
	V2DevicesJSONBodyCheckpointsDevice V2DevicesJSONBodyCheckpoints = "device"
	V2DevicesJSONBodyCheckpointsLogin  V2DevicesJSONBodyCheckpoints = "login"
)

// Address Address
type Address struct {
	// City City
	City    *string `json:"city,omitempty"`
	Company *string `json:"company,omitempty"`

	// CountryCode 2 letter Country code for the customer in [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) code e.g. US
	CountryCode *string `json:"countryCode,omitempty"`

	// PostalCode Postal (Zip) code
	PostalCode *string `json:"postalCode,omitempty"`

	// RegionCode The state or region for the customer. For USA and Canada, state code in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) code (e.g. CA) is preferred
	RegionCode *string `json:"regionCode,omitempty"`

	// Street1 Street Address
	Street1 *string `json:"street1,omitempty"`

	// Street2 Street Address
	Street2 *string `json:"street2,omitempty"`
}

// AllowList BlockList & AllowList data schema
type AllowList struct {
	// ClientId Account client ID of allowlist where item was added
	ClientId *string `json:"client_id,omitempty"`

	// Comment Optional comment provided when item was added to the allowlist.
	Comment *string `json:"comment,omitempty"`

	// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
	Expiry *float32 `json:"expiry,omitempty"`

	// Reason Source of the allowlisting request
	Reason *AllowListReason `json:"reason,omitempty"`

	// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
	RuleIds *[]int          `json:"ruleIds,omitempty"`
	Scope   *AllowListScope `json:"scope,omitempty"`
	Type    *AllowListType  `json:"type,omitempty"`

	// Value The value of the allowlisted item.
	Value *string `json:"value,omitempty"`
}

// AllowListReason Source of the allowlisting request
type AllowListReason string

// AllowListScope defines model for AllowList.Scope.
type AllowListScope string

// AllowListType defines model for AllowList.Type.
type AllowListType string

// AllowListWithoutClientIDandReason BlockList & AllowList data schema
type AllowListWithoutClientIDandReason struct {
	// Comment Optional comment provided when adding item to the allowlist.
	Comment *string `json:"comment,omitempty"`

	// Expiry This field is a unix timestamp which tells when this user expires from the allowList.
	Expiry *float32 `json:"expiry,omitempty"`

	// RuleIds List of rule IDs that allowlisting should be restricted to. If none are provided, the allowlisted item applies to all rules.
	RuleIds *[]int                                  `json:"ruleIds,omitempty"`
	Scope   *AllowListWithoutClientIDandReasonScope `json:"scope,omitempty"`

	// Type The type of item to be allowlisted.
	Type *AllowListWithoutClientIDandReasonType `json:"type,omitempty"`

	// Value The value of the allowlisted item.
	Value *string `json:"value,omitempty"`
}

// AllowListWithoutClientIDandReasonScope defines model for AllowListWithoutClientIDandReason.Scope.
type AllowListWithoutClientIDandReasonScope string

// AllowListWithoutClientIDandReasonType The type of item to be allowlisted.
type AllowListWithoutClientIDandReasonType string

// AmlEntity defines model for AmlEntity.
type AmlEntity struct {
	AdverseMedia *[]AmlObject `json:"adverseMedia,omitempty"`
	Alias        *[]string    `json:"alias,omitempty"`
	CountryCodes *[]string    `json:"countryCodes,omitempty"`
	DateOfBirths *[]string    `json:"dateOfBirths,omitempty"`
	EntityName   *string      `json:"entityName,omitempty"`

	// MatchScore possible score 0 to 100 higher the better. represents how close the entity match the given data
	MatchScore *int         `json:"matchScore,omitempty"`
	Pep        *[]AmlObject `json:"pep,omitempty"`

	// RiskScore possible score 0 to 100 higher the better. represents how risky a entity is.
	RiskScore *int         `json:"riskScore,omitempty"`
	Sanction  *[]AmlObject `json:"sanction,omitempty"`
}

// AmlObject defines model for AmlObject.
type AmlObject struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	SourceName  *string `json:"sourceName,omitempty"`
	SourceUrl   *string `json:"sourceUrl,omitempty"`
	SubCategory *string `json:"subCategory,omitempty"`
}

// Bank Bank account details
type Bank struct {
	// AccountNumber bank account number. *MUST* be at least 5 digits, otherwise the API will return a 422
	AccountNumber *string `json:"accountNumber,omitempty"`

	// AccountType checking, saving or other
	AccountType *BankAccountType `json:"accountType,omitempty"`

	// Balance last known bank balance in fractional units like cents
	Balance *float32 `json:"balance,omitempty"`

	// BalanceCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code
	BalanceCurrencyCode *string `json:"balanceCurrencyCode,omitempty"`

	// BicFull The full form of BIC is Bank Identifier Code. BIC is also better known as SWIFT ID, SWIFT-BIC, or SWIFT code, and it can be defined as a distinctive alpha-numerical identification code that is approved by the ISO or International Organization for Standardization.
	BicFull *string `json:"bicFull,omitempty"`

	// CheckNumber check number
	CheckNumber *string `json:"checkNumber,omitempty"`

	// Classification business, personal or other
	Classification *string `json:"classification,omitempty"`

	// IbanFull An IBAN, or international bank account number, is a standard international numbering system developed to identify an overseas bank account.
	IbanFull *string `json:"ibanFull,omitempty"`

	// Id id of bank in your system or in third party api (eg plaid)
	Id *string `json:"id,omitempty"`

	// IdSource source of id field (eg plaid)
	IdSource *string `json:"idSource,omitempty"`

	// IsCrossBorder indicates if the bank transfer is an international (cross-border) transaction
	IsCrossBorder *bool `json:"isCrossBorder,omitempty"`

	// RoutingNumber bank routing number
	RoutingNumber *string `json:"routingNumber,omitempty"`

	// SortCode Sort code
	SortCode *string `json:"sortCode,omitempty"`

	// TransferType ACH, sameDayACH, eCheck, fastPayment, RTP, FedNow, IAT or interbank
	TransferType *string `json:"transferType,omitempty"`
}

// BankAccountType checking, saving or other
type BankAccountType string

// BankData Information about bank account and transaction. Please specify this field if you don't use plaid
type BankData struct {
	// Accounts list of bank accounts and related information
	Accounts *[]struct {
		// AccountNumber bank account number
		AccountNumber string `json:"accountNumber"`

		// AccountType checking, saving or other
		AccountType string `json:"accountType"`

		// Balance Balance information
		Balance *struct {
			// Available available balance, in minor currency unit (eg. cents)
			Available *float32 `json:"available,omitempty"`

			// CurrencyCode currency code in ISO 3digit code (eg USD)
			CurrencyCode string `json:"currencyCode"`

			// Current current balance in minor currency unit (eg. cents)
			Current float32 `json:"current"`

			// LastUpdatedAt Unix timestamp indicating when balance was updated
			LastUpdatedAt *float32 `json:"lastUpdatedAt,omitempty"`
		} `json:"balance,omitempty"`

		// Id ID of bank account, defined by you or financial data provider
		Id string `json:"id"`

		// Name Name of bank account like "Wells Fargo high-interest savings account"
		Name *string `json:"name,omitempty"`

		// Owners account owners data
		Owners *[]struct {
			Addresses *[]struct {
				City    *string `json:"city,omitempty"`
				Country *string `json:"country,omitempty"`

				// IsPrimary if this is primary address for the bank
				IsPrimary  *string `json:"isPrimary,omitempty"`
				PostalCode *string `json:"postalCode,omitempty"`
				Region     *string `json:"region,omitempty"`
			} `json:"addresses,omitempty"`
			Emails *[]struct {
				// Email email address
				Email *string `json:"email,omitempty"`

				// IsPrimary if this is primary email address for the account
				IsPrimary *string `json:"isPrimary,omitempty"`
			} `json:"emails,omitempty"`

			// Names A list of names associated with the account (note this is string not array because many banks doesn't return names as array)
			Names        *string `json:"names,omitempty"`
			PhoneNumbers *[]struct {
				// IsPrimary if this is primary phone number for the account
				IsPrimary *string `json:"isPrimary,omitempty"`

				// PhoneNumber phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g.  +14151231234
				PhoneNumber *string `json:"phoneNumber,omitempty"`
			} `json:"phoneNumbers,omitempty"`
		} `json:"owners,omitempty"`

		// RoutingNumber bank routing number
		RoutingNumber string `json:"routingNumber"`
	} `json:"accounts,omitempty"`

	// Source finicity, yodlee or other
	Source *string `json:"source,omitempty"`

	// Transactions List of transactions
	Transactions *[]struct {
		// AccountId ID of bank account
		AccountId string `json:"accountId"`

		// Amount Amount in minor currency unit (eg cents)
		Amount float32 `json:"amount"`

		// Categories category such as overdraft, bankFee
		Categories *[]string `json:"categories,omitempty"`

		// CurrencyCode currency code in ISO 3digit code (eg USD)
		CurrencyCode string `json:"currencyCode"`

		// Description description of transaction, given by financial institution
		Description *string `json:"description,omitempty"`

		// Id ID of the transaction
		Id *string `json:"id,omitempty"`

		// Location location of transaction
		Location *struct {
			City       *string `json:"city,omitempty"`
			Country    *string `json:"country,omitempty"`
			Latitude   *string `json:"latitude,omitempty"`
			Longitude  *string `json:"longitude,omitempty"`
			PostalCode *string `json:"postalCode,omitempty"`
			Region     *string `json:"region,omitempty"`
			Street     *string `json:"street,omitempty"`
		} `json:"location,omitempty"`

		// MerchantName Name of merchant
		MerchantName *string `json:"merchantName,omitempty"`

		// PostedDate Date when transction was posted in YYYY-MM-DD format
		PostedDate *string `json:"postedDate,omitempty"`

		// Status active or pending
		Status *string `json:"status,omitempty"`

		// TransactionDate Date when transction took place in YYYY-MM-DD format
		TransactionDate *string `json:"transactionDate,omitempty"`

		// Type type of transction. one of atm, cash, check, credit, debit, deposit, directDebit, directDeposit, dividend, fee, intrest, payment, pointOfSale, repeatPayment, serviceCharge, transfer or other.
		Type *string `json:"type,omitempty"`
	} `json:"transactions,omitempty"`
}

// BizAddress The Business address. This is not required for the Advanced AML Screening use case.
type BizAddress struct {
	// City City
	City string `json:"city"`

	// CountryCode 2 letter Country code for the customer in [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) code e.g. US
	CountryCode *string `json:"countryCode,omitempty"`

	// PostalCode Postal (Zip) code
	PostalCode string `json:"postalCode"`

	// RegionCode The state code in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) code (e.g. CA)
	RegionCode string `json:"regionCode"`

	// Street1 Street Address
	Street1 string `json:"street1"`

	// Street2 Street Address
	Street2 *string `json:"street2,omitempty"`
}

// BizAmlEntities This object is only avaliable if you use advancedAmlScreening in synchronous mode.
type BizAmlEntities = []struct {
	AdverseMedia *struct {
		// Level Adverse media level
		Level   *BizAmlEntitiesAdverseMediaLevel `json:"level,omitempty"`
		Sources *[]struct {
			// Category Category of the adverse media
			Category *string `json:"category,omitempty"`

			// Description Description of the adverse media
			Description *string `json:"description,omitempty"`

			// SourceName Name of the adverse media source
			SourceName *string `json:"sourceName,omitempty"`

			// SourceUrl URL to the source of the adverse media
			SourceUrl *string `json:"sourceUrl,omitempty"`

			// SubCategory Sub-category of the adverse media
			SubCategory *string `json:"subCategory,omitempty"`
		} `json:"sources,omitempty"`
	} `json:"adverseMedia,omitempty"`
	CountryCodes *[]string `json:"countryCodes,omitempty"`

	// EntityName Name of the entity
	EntityName *string `json:"entityName,omitempty"`

	// MatchScore Match score indicating the likelihood of a match (0-100 with 100 highest match)
	MatchScore *int `json:"matchScore,omitempty"`
	Pep        *struct {
		// Level Pep level
		Level   *BizAmlEntitiesPepLevel `json:"level,omitempty"`
		Sources *[]struct {
			// Description Description of the Pep
			Description *string `json:"description,omitempty"`

			// SourceName Name of the Pep source
			SourceName *string `json:"sourceName,omitempty"`

			// SourceUrl URL to the source of the Pep
			SourceUrl *string `json:"sourceUrl,omitempty"`
		} `json:"sources,omitempty"`
	} `json:"pep,omitempty"`

	// RiskLevel Risk level associated with the entity
	RiskLevel *BizAmlEntitiesRiskLevel `json:"riskLevel,omitempty"`

	// RiskScore Risk score associated with the entity (0-100 with 100 highest risk)
	RiskScore *int `json:"riskScore,omitempty"`
	Sanction  *struct {
		// Level Sanction level
		Level   *BizAmlEntitiesSanctionLevel `json:"level,omitempty"`
		Sources *[]struct {
			// Description Description of the sanction
			Description *string `json:"description,omitempty"`

			// SourceName Name of the sanction source
			SourceName *string `json:"sourceName,omitempty"`

			// SourceUrl URL to the source of the sanction
			SourceUrl *string `json:"sourceUrl,omitempty"`
		} `json:"sources,omitempty"`
	} `json:"sanction,omitempty"`
}

// BizAmlEntitiesAdverseMediaLevel Adverse media level
type BizAmlEntitiesAdverseMediaLevel string

// BizAmlEntitiesPepLevel Pep level
type BizAmlEntitiesPepLevel string

// BizAmlEntitiesRiskLevel Risk level associated with the entity
type BizAmlEntitiesRiskLevel string

// BizAmlEntitiesSanctionLevel Sanction level
type BizAmlEntitiesSanctionLevel string

// BizConfig defines model for BizConfig.
type BizConfig struct {
	AdvancedAmlScreening *struct {
		// IsEnabled Flag indicating whether advance AML check is enabled
		IsEnabled *bool `json:"isEnabled,omitempty"`

		// IsSync Flag indicating whether AML screening is synchronous; should all ways be true. because asynchronous advanceAmlScreening is still a work in progress.
		IsSync *bool `json:"isSync,omitempty"`

		// Mode when this flag is set the business is monitered moving forward any existing alerts will not be surfaces.
		Mode *BizConfigAdvancedAmlScreeningMode `json:"mode,omitempty"`
	} `json:"advancedAmlScreening,omitempty"`
	BusinessLookup *struct {
		// AdvancedEnrichment Flag indicating whether advanced business enrichment is enabled
		AdvancedEnrichment *bool `json:"advancedEnrichment,omitempty"`

		// EmailEnrichment Flag indicating whether email enrichment is enabled
		EmailEnrichment *bool `json:"emailEnrichment,omitempty"`

		// FastEnrichment Flag indicating whether fast business enrichment is enabled
		FastEnrichment *bool `json:"fastEnrichment,omitempty"`

		// IsEnabled Flag indicating whether business lookup is enabled
		IsEnabled *bool `json:"isEnabled,omitempty"`

		// SlowEnrichment Flag indicating whether slow business enrichment is enabled
		SlowEnrichment *bool `json:"slowEnrichment,omitempty"`
	} `json:"businessLookup,omitempty"`

	// Checkpoints Name of the checkpoints to be invoked. *Please discuss with Sardine.* `business` checkpoint will be executed by default if checkpoints array is omitted.
	Checkpoints *[]BizConfigCheckpoints `json:"checkpoints,omitempty"`

	// KybLevel Type of KYB screening being run
	KybLevel BizConfigKybLevel `json:"kybLevel"`
}

// BizConfigAdvancedAmlScreeningMode when this flag is set the business is monitered moving forward any existing alerts will not be surfaces.
type BizConfigAdvancedAmlScreeningMode string

// BizConfigCheckpoints defines model for BizConfig.Checkpoints.
type BizConfigCheckpoints string

// BizConfigKybLevel Type of KYB screening being run
type BizConfigKybLevel string

// BizConfigGetResponse defines model for BizConfigGetResponse.
type BizConfigGetResponse struct {
	AdvancedAmlScreening *struct {
		// IsEnabled Flag indicating whether advance AML check is enabled
		IsEnabled *bool `json:"isEnabled,omitempty"`

		// IsSync Flag indicating whether AML screening is synchronous; should all ways be true. because asynchronous advanceAmlScreening is still a work in progress.
		IsSync *bool `json:"isSync,omitempty"`

		// Mode when this flag is set the business is monitered moving forward any existing alerts will not be surfaces.
		Mode *BizConfigGetResponseAdvancedAmlScreeningMode `json:"mode,omitempty"`
	} `json:"advancedAmlScreening,omitempty"`
	BusinessLookup *struct {
		// IsEnabled Flag indicating whether business lookup is enabled
		IsEnabled *bool `json:"isEnabled,omitempty"`
	} `json:"businessLookup,omitempty"`

	// KybLevel Type of KYB screening being run
	KybLevel BizConfigGetResponseKybLevel `json:"kybLevel"`
}

// BizConfigGetResponseAdvancedAmlScreeningMode when this flag is set the business is monitered moving forward any existing alerts will not be surfaces.
type BizConfigGetResponseAdvancedAmlScreeningMode string

// BizConfigGetResponseKybLevel Type of KYB screening being run
type BizConfigGetResponseKybLevel string

// BizCustomer Customer details
type BizCustomer struct {
	// Address The Business address. This is not required for the Advanced AML Screening use case.
	Address *BizAddress `json:"address,omitempty"`

	// DateOfBirth int64
	DateOfBirth      *int    `json:"dateOfBirth,omitempty"`
	EmailAddress     *string `json:"emailAddress,omitempty"`
	FirstName        string  `json:"firstName"`
	LastName         string  `json:"lastName"`
	MiddleName       *string `json:"middleName,omitempty"`
	OwnershipPercent *int    `json:"ownershipPercent,omitempty"`

	// Phone The customer''s phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
	Phone *string `json:"phone,omitempty"`

	// Prong if he owns >25% this field should be ownership or it should be control if he owns the majority of the company
	Prong *BizCustomerProng `json:"prong,omitempty"`

	// TaxId SSN if customer is a end-user. Otherwise, omit this field altogether. Valid formats include: 123-45-6789 or 123456789. *Do not* send an empty string. <br/>The API will return a 422 if either an empty string or incorrect formatting is used.
	TaxId *string `json:"taxId,omitempty"`
}

// BizCustomerProng if he owns >25% this field should be ownership or it should be control if he owns the majority of the company
type BizCustomerProng string

// BlockList BlockList & AllowList data schema.
type BlockList struct {
	// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
	ClientId *string `json:"client_id,omitempty"`

	// Comment Optional comment provided when item was added to the blocklist.
	Comment *string `json:"comment,omitempty"`

	// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
	Expiry *float32 `json:"expiry,omitempty"`

	// Reason Source of the blocklisting request.
	Reason *BlockListReason `json:"reason,omitempty"`
	Scope  *BlockListScope  `json:"scope,omitempty"`

	// Type The type of item to be blocklisted.
	Type *BlockListType `json:"type,omitempty"`

	// Value The value of the blocklisted item.
	Value *string `json:"value,omitempty"`
}

// BlockListReason Source of the blocklisting request.
type BlockListReason string

// BlockListScope defines model for BlockList.Scope.
type BlockListScope string

// BlockListType The type of item to be blocklisted.
type BlockListType string

// BlockListWithoutClientIDandReason BlockList & AllowList data schema
type BlockListWithoutClientIDandReason struct {
	// Comment Optional comment provided when adding item to the blocklist.
	Comment *string `json:"comment,omitempty"`

	// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
	Expiry *float32                                `json:"expiry,omitempty"`
	Scope  *BlockListWithoutClientIDandReasonScope `json:"scope,omitempty"`

	// Type The type of item to be blocklisted.
	Type *BlockListWithoutClientIDandReasonType `json:"type,omitempty"`

	// Value The value of the blocklisted item.
	Value *string `json:"value,omitempty"`
}

// BlockListWithoutClientIDandReasonScope defines model for BlockListWithoutClientIDandReason.Scope.
type BlockListWithoutClientIDandReasonScope string

// BlockListWithoutClientIDandReasonType The type of item to be blocklisted.
type BlockListWithoutClientIDandReasonType string

// Business defines model for Business.
type Business struct {
	// Address The Business address. This is not required for the Advanced AML Screening use case.
	Address        BizAddress            `json:"address"`
	AnnualTurnOver *int64                `json:"annualTurnOver,omitempty"`
	Categories     *[]BusinessCategories `json:"categories,omitempty"`

	// CustomerIds List of IDs for the business representatives. Those should be the same IDs as used in Sardine customers API calls.
	CustomerIds *[]string `json:"customerIds,omitempty"`

	// EmailAddress The business email address
	EmailAddress *string `json:"emailAddress,omitempty"`

	// IncorporationDateMillis Date when the business was incorporated
	IncorporationDateMillis *int64 `json:"incorporationDateMillis,omitempty"`

	// Name The name of the business. It is limited to 128 characters for the Advanced AML Screening use case.
	Name string `json:"name"`

	// Names Other names used for this business
	Names *[]string `json:"names,omitempty"`

	// Phone The business phone numbers in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
	Phone           []string        `json:"phone"`
	Representatives *[]BizCustomer  `json:"representatives,omitempty"`
	Sources         *[]Source       `json:"sources,omitempty"`
	Tags            *[]BusinessTags `json:"tags,omitempty"`

	// TaxId The business Employer Identification Number (EIN)
	TaxId string `json:"taxId"`

	// TrackingId If trackingId is passed, a new business ID will be returned if one doesn't already exist; otherwise, the existing business ID will be returned. If no trackingId is passed, a new business is created with a Sardine-assigned ID.
	TrackingId *string `json:"trackingId,omitempty"`

	// Website The business website. This must include the http:// or https://
	Website string `json:"website"`
}

// BusinessCategories defines model for Business.Categories.
type BusinessCategories string

// BusinessTags defines model for Business.Tags.
type BusinessTags string

// CanadaConsumer defines model for CanadaConsumer.
type CanadaConsumer struct {
	// AddressMatchScore Score indicating the match of consumer's address
	AddressMatchScore *int `json:"addressMatchScore,omitempty"`

	// ErrorMessage Error message, if any
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	Match        *DataZooMatch `json:"match,omitempty"`

	// NameMatchScore Score indicating the match of consumer's name
	NameMatchScore *int `json:"nameMatchScore,omitempty"`

	// Status Status of this position of the international eKYC. The possible values are 'Successful' and 'Error'.
	Status *string `json:"status,omitempty"`

	// Verified Whether the consumer is verified
	Verified *bool `json:"verified,omitempty"`
}

// CanadaCreditBureau defines model for CanadaCreditBureau.
type CanadaCreditBureau struct {
	// AddressMatchScore Score indicating the match of consumer's address
	AddressMatchScore *int `json:"addressMatchScore,omitempty"`

	// ErrorMessage Error message, if any
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	Match        *DataZooMatch `json:"match,omitempty"`

	// NameMatchScore Score indicating the match of consumer's name
	NameMatchScore *int             `json:"nameMatchScore,omitempty"`
	ReportedData   *DataZooReported `json:"reportedData,omitempty"`

	// Status Status of this position of the international eKYC. The possible values are 'Successful' and 'Error'.
	Status *string `json:"status,omitempty"`

	// Verified Whether the consumer is verified
	Verified *bool `json:"verified,omitempty"`
}

// Card Card information
type Card struct {
	// Balance Balance of debit card / prepaid card in fractional units like cents
	Balance *float32 `json:"balance,omitempty"`

	// BalanceCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code
	BalanceCurrencyCode *string `json:"balanceCurrencyCode,omitempty"`

	// Bin Bin (first 6 or 8 digits) of card number. <br/>*IMPORTANT*: Please note that for American Express (AMEX) cards, this is always the first 6 digits of the card number. <br/><br/>For all other cards, please simply pull the BIN from the card (either first 6 or 8 for Discover, JCB, Mastercard, UnionPay, or Visa).
	Bin *string `json:"bin,omitempty"`

	// BinCountry Two-letter ISO code representing the country of the card BIN (bank identification number)
	BinCountry *string `json:"binCountry,omitempty"`

	// Brand Card brand. Can be American Express, Diners Club, Discover, JCB, MasterCard, UnionPay, Visa, or Unknown.
	Brand *string `json:"brand,omitempty"`

	// CreditCardAuthorization Information you get as part of credit card authorization
	CreditCardAuthorization *CreditCardAuthorization `json:"creditCardAuthorization,omitempty"`

	// ExpiryMonth Expiration month of the card used for this transaction; should be a value between 1-12
	ExpiryMonth *int `json:"expiryMonth,omitempty"`

	// ExpiryYear Expiration year of the card used for this transaction; min value is 2022 and the max value is 2100.
	ExpiryYear *int `json:"expiryYear,omitempty"`

	// Hash  [Sha-256](https://en.wikipedia.org/wiki/SHA-2)  hash of card number (PAN). Please use a salt with the SHA256 algorithm on the PAN. If you cannot provide a hash of the full card number, please use some unique identifier here noting that it's this particular card without containing the actual card number, e.g., row id in your db. Lastly, please do not pass this field as a hash of only BIN + last4 as it may cause false positives.
	Hash *string `json:"hash,omitempty"`

	// IsVerified If ownership of card is verified via card 2fA (sending small amount authorization to card and asking user to confirm authorization details)
	IsVerified *bool `json:"isVerified,omitempty"`

	// Last4 Last 4 digit of card number
	Last4 *string `json:"last4,omitempty"`
}

// CheckPointsResponse Result of rule evaluations for each checkpoint. `customer` checkpoint is executed by default.
type CheckPointsResponse map[string]map[string]struct {
	// RuleIds list of rule IDs that were evaluated as true
	RuleIds *[]int  `json:"ruleIds,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// CheckPointsResponseIssuing Result of rule evaluations for each checkpoint. `issuingrisk` checkpoint is executed by default.
type CheckPointsResponseIssuing map[string]map[string]struct {
	// RuleIds list of rule IDs that were evaluated as true
	RuleIds *[]int  `json:"ruleIds,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// ClientList defines model for ClientList.
type ClientList struct {
	// ClientId Sardine client identifier for the account the listed item belongs to.
	ClientId *string `json:"client_id,omitempty"`

	// Id Sardine internal identifier for the custom list
	Id        *int         `json:"id,omitempty"`
	ListItems *[]ListItems `json:"list_items,omitempty"`

	// Name Name of the custom list you are creating.
	Name *string `json:"name,omitempty"`
}

// Config Config Object. Default config values to enable/disable various Sardine functionality is done at merchant level. For some merchants, Sardine may allow overriding the default configuration. eg By default, sanction screening may be enabled for all api calls for a merchant and Sardine *may* allow selective sanction screening to be enabled via config.
type Config struct {
	// AdverseMedia Determines if Adverse Media screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	AdverseMedia *ConfigAdverseMedia `json:"adverseMedia,omitempty"`

	// Bank Determines if bank consortium data enrichment should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	Bank *bool `json:"bank,omitempty"`

	// Device Determines if device intelligence and behaviour biometrics SDK data is expected for this session. Please set to `false` for any flows where it is know the Sardine SDK is not integrated and no device data is collected.
	Device *bool `json:"device,omitempty"`

	// DisablePM If set to `true`, the user from this request will not be subscribed to ongoing sanction monitoring. The default behavior if omitted is determined by your account-level setting. This flag can only be used to disable ongoing monitoring, setting it to `false` will not subscribe a user to ongoing monitoring.
	DisablePM *bool `json:"disablePM,omitempty"`

	// Email Determines if email data enrichment should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	Email *bool `json:"email,omitempty"`

	// IndemnificationFlg Determined if the Sardine transaction indemnification details should be returned in the API response (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	IndemnificationFlg *bool `json:"indemnificationFlg,omitempty"`

	// Pep Determines if Politically Exposed Person (PEP) screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	Pep *ConfigPep `json:"pep,omitempty"`

	// Phone Determines if phone data enrichment should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	Phone *bool `json:"phone,omitempty"`

	// RiskCheck If set to false, no riskLevel will be returned and this request will provide a one-way data feed to Sardine. By default, if this field is not provided, riskCheck is set to true. Please ensure you discuss this with your Integration Manager prior to implementing this config.
	RiskCheck *bool `json:"riskCheck,omitempty"`

	// Sanction Determines if Sanction screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	Sanction *ConfigSanction `json:"sanction,omitempty"`

	// ScreenCounterparty If set to `true`, Sardine will sanction screen the counterparty (`counterparty`) of the transaction. By default, `screenCounterparty` is set to `false`. Please ensure you discuss this with your Integration Manager prior to implementing this config.
	ScreenCounterparty *bool `json:"screenCounterparty,omitempty"`

	// ScreenCounterpartyBank If set to `true`, Sardine will sanction screen the bank of the counterparty (`counterparty.paymentMethod`) of the transaction. By default, `screenCounterpartyBank` is set to `false`. Please ensure you discuss this with your Integration Manager prior to implementing this config.
	ScreenCounterpartyBank *bool `json:"screenCounterpartyBank,omitempty"`

	// TaxIdVerification Determines if Tax ID verification should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	TaxIdVerification *bool `json:"taxIdVerification,omitempty"`

	// WalletScreening Determines if crypto wallet verification should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
	WalletScreening *bool `json:"walletScreening,omitempty"`
}

// ConfigAdverseMedia Determines if Adverse Media screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
type ConfigAdverseMedia string

// ConfigPep Determines if Politically Exposed Person (PEP) screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
type ConfigPep string

// ConfigSanction Determines if Sanction screening should be run on this request (assuming valid required input data is provided). The default behavior if omitted is determined by your account-level setting.
type ConfigSanction string

// CreditCardAuthorization Information you get as part of credit card authorization
type CreditCardAuthorization struct {
	// N3ds Result of 3DS. Valid values are: success, issuer_not_supported, signature_verification_failed, rejected, frictionless_failed, error, and bypassed
	N3ds *string `json:"3ds,omitempty"`

	// Avs Reason code returned by AVS check from processor
	Avs *string `json:"avs,omitempty"`

	// AvsStreet Result of AVS check for street address. match, nomatch, not_verified, error or nodata.
	AvsStreet *string `json:"avsStreet,omitempty"`

	// AvsZip Result of AVS check for zip code. match, nomatch, not_verified, error or nodata.
	AvsZip *string `json:"avsZip,omitempty"`

	// Cvv Result of cvv match check. match, nomatch, not_verified, not_supported, or error.
	Cvv *string `json:"cvv,omitempty"`

	// Processor Example: checkout
	Processor *string `json:"processor,omitempty"`

	// Status e.g approved, and declined.
	Status *string `json:"status,omitempty"`

	// StatusCode Example - 10000, 20001. This could be an authorization code or a decline code.
	StatusCode *string `json:"statusCode,omitempty"`
}

// Crypto Crypto address
type Crypto struct {
	// Address crypto address
	Address *string `json:"address,omitempty"`

	// AssetSymbol Crypto asset symbol e.g. USDT, BTC, ETH etc.
	AssetSymbol *string `json:"assetSymbol,omitempty"`

	// Network Cryptocurrency network or blockchain of the given asset. It must be one of the allowed values:
	Network *CryptoNetwork `json:"network,omitempty"`

	// TransactionHash The identifier uniquely identify the transaction.
	TransactionHash *string `json:"transactionHash,omitempty"`
}

// CryptoNetwork Cryptocurrency network or blockchain of the given asset. It must be one of the allowed values:
type CryptoNetwork string

// Customer Customer details
type Customer struct {
	// Address Address
	Address      *Address `json:"address,omitempty"`
	BusinessName *string  `json:"businessName,omitempty"`

	// ConsentStatus Whether customer give a consent to pull data from carrier. 'unknown', 'optedIn' or 'optedOut'. Default 'unknown'
	ConsentStatus *string `json:"consentStatus,omitempty"`

	// CreatedAtMillis This is time the customer was onboarded/created in your system. Please pass it as Unix timestamp in *milliseconds*. e.g. 1622057169587 for Wed May 22021 19:26:09
	CreatedAtMillis *int64 `json:"createdAtMillis,omitempty"`

	// DateOfBirth The customer's date of birth in format YYYY-MM-DD. The API will return a 422 if the customer's age is <1 or >150 years old.
	DateOfBirth *string `json:"dateOfBirth,omitempty"`

	// Domain domain of business (eg sardine.ai)
	Domain       *string `json:"domain,omitempty"`
	EmailAddress *string `json:"emailAddress,omitempty"`
	FirstName    *string `json:"firstName,omitempty"`

	// Id User ID hash. Please use the same value as passed to device intelligence SDK
	Id string `json:"id"`

	// IncomeAmount yearly income amount in major units, e.g., 50000 for fifty-thousand
	IncomeAmount *float32 `json:"incomeAmount,omitempty"`

	// IncomeCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
	IncomeCurrencyCode *string `json:"incomeCurrencyCode,omitempty"`

	// IsEmailVerified true if email is verified
	IsEmailVerified *bool `json:"isEmailVerified,omitempty"`

	// IsPhoneVerified true if phone number is verified
	IsPhoneVerified *bool           `json:"isPhoneVerified,omitempty"`
	LastName        *string         `json:"lastName,omitempty"`
	MiddleName      *string         `json:"middleName,omitempty"`
	PersonalInfo    *[]PersonalInfo `json:"personalInfo,omitempty"`

	// Phone The customer's phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
	Phone *string `json:"phone,omitempty"`

	// Status status of user in merchant's system: 'active' or 'inactive'
	Status *string `json:"status,omitempty"`

	// Tags List of tags associated with the customer entity
	Tags *[]Tags `json:"tags,omitempty"`

	// TaxId SSN or ITIN if customer is a end-user. EIN if customer is an company. <br/><b>IMPORTANT:</b> only populate when you have a valid SSN or EIN. Otherwise, omit this field altogether. Valid formats include: 123-45-6789 or 123456789. *Do not* send an empty string. <br/>The API will return a 422 if either an empty string or incorrect formatting is used.
	TaxId *string `json:"taxId,omitempty"`

	// Type This is the type of customer entity represented, e.g., standard end-user (customer), a vendor, business, etc.
	Type *CustomerType `json:"type,omitempty"`
}

// CustomerType This is the type of customer entity represented, e.g., standard end-user (customer), a vendor, business, etc.
type CustomerType string

// CustomerResponse customer riskiness level and associated signals
type CustomerResponse struct {
	Address *struct {
		// Validity Whether the customer provided address is valid or not. Possible values - valid, invalid, unknown.
		Validity *string `json:"validity,omitempty"`
	} `json:"address,omitempty"`
	Aml        *AmlEntity   `json:"aml,omitempty"`
	AmlEntites *[]AmlEntity `json:"amlEntites,omitempty"`
	Bank       *struct {
		// IsNachaDebitCompatible Whether account is nacha debit compatible. Possible values - true, false, unknown.
		IsNachaDebitCompatible *string `json:"isNachaDebitCompatible,omitempty"`
		Nsf                    *struct {
			// NormalizedScore Normalized risk score for non-sufficient funds. This is a number between 0 and 99, with 99 being the highest risk. For example, Score of 95 means it is risker than 95% of the transaction.
			NormalizedScore *float32 `json:"normalizedScore,omitempty"`

			// Score ML Risk score for non-sufficient funds for a given transaction. This is a number between 0 and 99, with 99 being the highest risk. The score can be used once feedback for historical transactions has been provided. Note, the score can change with time as the model is retrained.
			Score *float32 `json:"score,omitempty"`
		} `json:"nsf,omitempty"`
	} `json:"bank,omitempty"`

	// Level Riskiness of the customer. "very_high", "high", "medium", "low". This field is based on rule evaluations (which utilizes ML model score and various other features) for customer checkpoint or custom checkpoints provided by you.
	Level *string `json:"level,omitempty"`
	Phone *struct {
		// AddressScore A score of the address match; values -1 to 100. 100 indicates an exact match. 0 indicates no match. -1 indicates no information found.
		AddressScore *float32 `json:"addressScore,omitempty"`

		// CityMatch The results of the city match; true or false.
		CityMatch *bool `json:"cityMatch,omitempty"`

		// NameScore A score of the name match; values -1 to 100. 100 indicates an exact match. 0 indicates no match. -1 indicates no information found.
		NameScore *float32 `json:"nameScore,omitempty"`

		// PostalCodeMatch The results of the postal/zip code match; true or false.
		PostalCodeMatch *bool `json:"postalCodeMatch,omitempty"`
		Prove           *struct {
			// AddressScore An overall address score that uses all the address attributes to generate the overall score; values 0 to 100. 100 indicates an exact match.
			AddressScore *float32 `json:"addressScore,omitempty"`

			// CityMatch The results of the city match; true or false
			CityMatch *bool `json:"cityMatch,omitempty"`

			// DobMatch The results of the dob match; true or false
			DobMatch *bool `json:"dobMatch,omitempty"`

			// EmailMatch The results of the email match; true or false
			EmailMatch *bool `json:"emailMatch,omitempty"`

			// FirstNameScore A score of the first name match; values -1 to 100. 100 indicates an exact match.
			FirstNameScore *float32 `json:"firstNameScore,omitempty"`

			// LastNameScore A score of the last name match; values -1 to 100. 100 indicates an exact match.
			LastNameScore *float32 `json:"lastNameScore,omitempty"`

			// PostalCodeMatch The results of the postal/zip ode match; true or false
			PostalCodeMatch *bool `json:"postalCodeMatch,omitempty"`

			// RegionMatch The results of the region (state abbreviation) match; true or false
			RegionMatch *bool `json:"regionMatch,omitempty"`

			// SsnMatch The results of the full ssn match; true or false
			SsnMatch *bool `json:"ssnMatch,omitempty"`

			// StreetMatch The results of the street name match; true or false
			StreetMatch *bool `json:"streetMatch,omitempty"`

			// StreetNumberScore A score of the street number; values -1 to 100. 100 indicates an exact match.
			StreetNumberScore *float32 `json:"streetNumberScore,omitempty"`
		} `json:"prove,omitempty"`

		// RegionMatch The results of the region (state abbreviation) match; true or false.
		RegionMatch *bool `json:"regionMatch,omitempty"`
	} `json:"phone,omitempty"`
	ReasonCodes *[]string `json:"reasonCodes,omitempty"`

	// Score ML Risk Score for the current customer session. The ML model used to predict the score is trained on velocity and aggregation features, phone, email, bank, tax, card, IP, location, device and behavior intelligence signals. The score can be used once feedback for historical transactions has been provided.
	Score *float32 `json:"score,omitempty"`

	// Signals | Name | Description |Values|
	// |--------|---------|------------|
	// | cryptoUserLevel | User Level risk scoring based on crypto address screening.|high/medium/low|
	// | emailDomainLevel | Risk level of email domain like .com, .me |high/medium/low |
	// | addressRiskLevel | The risk level of the customer provided address |high/medium/low |
	// | amlRiskLevel |AML risk level set by AML rules. Only populated when you call AML-related checkpoints.  |high/medium/low |
	// | taxIdLevel | Risk level of taxId. Only available if KYC is enabled for your account.|high/medium/low|
	// | taxIdMatch | If provided taxID matches known record searched via provided taxId, name, dob and state. Only available if KYC is enabled for your account. |exact/fuzzy/nomatch|
	// | taxIdNameMatch | If the provided name matches with known taxID record searched via provided taxId, name, dob and state. Only available, if KYC is enabled for your account.|exact/fuzzy/nomatch|
	// | phoneCarrier |phone carrier name (eg Verizon). | Verizon, BANDWIDTH.COM, etc |
	// | phoneLineType |  phone line type (eg Mobile).| Landline, FixedVoIP, NonFixedVoIP, Mobile, Other |
	// | taxIdStateMatch | If the provided state matches known taxID record searched via provided taxId, name, dob and state. Only available, if KYC is enabled for your account.|exact/fuzzy/nomatch|
	// | sanctionLevel | Check if the customer belongs to sanction list like SDN/OFAC. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
	// | pepLevel | Check if the customer belongs to PEP(Politically Exposed Person) list. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
	// | adverseMediaLevel | Check if the customer has any associated adverse media . Only available if Sanctions Screening is enabled for your account.|high/medium/low|
	// | cryptoAddressLevel | Check if the crypto address is associated with risky activity like DarkNet. Only available, if Crypto AML Screening is enabled for your account.|high/medium/low|
	// | nsfLevel | Estimate likelihood of bank account not having sufficient funds. |high/medium/low|
	// | manualReview | Status of the case if the session was added to the queue for manual review or not |true/false|
	Signals *[]Signal `json:"signals,omitempty"`
	TaxID   *struct {
		// Sentilink raw signals we get from sentilink. Each score is from 0 to 1000, with higher value indicating higher propensity for fraud.
		Sentilink *struct {
			// AbuseScore The identity is synthetic or the identity has previously been associated with fraudulent behaviors such as the purchase of authorized user tradelines.
			AbuseScore *float32 `json:"abuseScore,omitempty"`

			// FirstPartySyntheticScore The identity is a first party synthetic. The application consists of a true name and DOB but a fictitious SSN. Commonly used when the applicant is trying to hide parts of their true profile.
			FirstPartySyntheticScore *float32 `json:"firstPartySyntheticScore,omitempty"`

			// IdTheftScore The identity is a victim of ID theft.
			IdTheftScore *float32 `json:"idTheftScore,omitempty"`

			// ThirdPartySyntheticScore The identity is a third party synthetic. The application consists of a name, DOB, and SSN that describe a fictitious person. Commonly used by fraudsters, often in organized crime rings, to commit financial crimes.
			ThirdPartySyntheticScore *float32 `json:"thirdPartySyntheticScore,omitempty"`
		} `json:"sentilink,omitempty"`
	} `json:"taxID,omitempty"`
	Verification *struct {
		CanadaConsumer     *CanadaConsumer     `json:"canadaConsumer,omitempty"`
		CanadaCreditBureau *CanadaCreditBureau `json:"canadaCreditBureau,omitempty"`
	} `json:"verification,omitempty"`
}

// DataZooMatch defines model for DataZooMatch.
type DataZooMatch struct {
	// City Whether the city matches
	City *bool `json:"city,omitempty"`

	// DateOfBirth Whether the date of birth matches
	DateOfBirth *bool `json:"dateOfBirth,omitempty"`

	// EmailAddress Whether the email address matches
	EmailAddress *bool `json:"emailAddress,omitempty"`

	// FirstName Whether the first name matches
	FirstName *bool `json:"firstName,omitempty"`

	// LastName Whether the last name matches
	LastName *bool `json:"lastName,omitempty"`

	// Phone Whether the phone number matches
	Phone *bool `json:"phone,omitempty"`

	// PostalCode Whether the postal code matches
	PostalCode *bool `json:"postalCode,omitempty"`

	// RegionCode Whether the region code matches
	RegionCode *bool `json:"regionCode,omitempty"`

	// Street1 Whether the street1 matches
	Street1 *bool `json:"street1,omitempty"`

	// Street2 Whether the street2 matches
	Street2 *bool `json:"street2,omitempty"`
}

// DataZooReported defines model for DataZooReported.
type DataZooReported struct {
	// AddressAsReported Address as reported
	AddressAsReported *string `json:"addressAsReported,omitempty"`

	// Category Category of the reported data
	Category *string `json:"category,omitempty"`

	// Cid CID (Credit Identification) of the consumer
	Cid *string `json:"cid,omitempty"`

	// CreditFile3Years Whether the credit file exists for the last 3 years
	CreditFile3Years *bool `json:"creditFile3Years,omitempty"`

	// CreditFileCreated Date when the credit file was created
	CreditFileCreated *string `json:"creditFileCreated,omitempty"`

	// DateOfBirthAsReported Date of birth as reported
	DateOfBirthAsReported *string `json:"dateOfBirthAsReported,omitempty"`

	// MoreThanOneDistinctSource Whether the data comes from more than one distinct source
	MoreThanOneDistinctSource *bool `json:"moreThanOneDistinctSource,omitempty"`

	// NameAsReported Name as reported
	NameAsReported *string `json:"nameAsReported,omitempty"`

	// NumberOfTrades Number of trades reported
	NumberOfTrades *string `json:"numberOfTrades,omitempty"`

	// OriginOfCreditFile Origin of the credit file
	OriginOfCreditFile *string `json:"originOfCreditFile,omitempty"`

	// Source Source of the reported data
	Source *string `json:"source,omitempty"`
}

// Device Device details
type Device struct {
	// CreatedAtMillis This is the time the device was seen in your system. Please pass it as a Unix timestamp in milliseconds. e.g., 1622057169587 for Wed May 22021 19:26:09
	CreatedAtMillis *int64 `json:"createdAtMillis,omitempty"`

	// Fingerprint Fingerprint of the device/browser
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id ID of device given by specified source (see source parameter below)
	Id *string `json:"id,omitempty"`

	// Ip IP address with which device is associated to. can be either IPv4 or IPV6
	Ip *string `json:"ip,omitempty"`

	// Language The accept-language HTTP header (Language Culture Name). Examples: (en-EN, de-DE)
	Language *string `json:"language,omitempty"`

	// Source Source from where the deviceId was created, e.g., Sardine, Merchant A, Other. Please note: if the source provided is not 'Sardine', IP-related details will be returned in the place of device intelligence features
	Source *string `json:"source,omitempty"`

	// Status Indicating if device is blocked by merchant's system. allowed or blocked
	Status *string `json:"status,omitempty"`

	// UserAgent userAgent header
	UserAgent *string `json:"userAgent,omitempty"`
}

// DeviceCheckpointsResponse Result of rule evaluations for each checkpoint. `device` checkpoint is executed by default.
type DeviceCheckpointsResponse map[string]map[string]struct {
	// RuleIds list of rule IDs that were evaluated as true
	RuleIds *[]int  `json:"ruleIds,omitempty"`
	Value   *string `json:"value,omitempty"`
}

// DevicesResponse Device riskiness level and associated signals
type DevicesResponse struct {
	// Attributes Attributes of the device like OS, Model & Browser. Please expand to see field description.
	Attributes *struct {
		// Browser Value of "App" for Native Apps. For web, detected browser. eg Chrome Mobile, Chrome, Mobile Safari, Firefox, Safari
		Browser *[]string `json:"Browser,omitempty"`

		// Model Model of the mobile device. For Web, it will be extracted as it is from UserAgent header (in android only). e.g. SM-G900P (Samsung S5)
		Model *[]string `json:"Model,omitempty"`

		// OS For Web, it will be extracted from the UserAgent header. eg "iOS", "Mac OS X", "Android", "Windows" or "Linux". For mobile SDKs it's constant "Android" or "iOS"
		OS *[]string `json:"OS,omitempty"`
	} `json:"attributes,omitempty"`

	// BehaviorBiometrics Behavior biometric data Signals
	BehaviorBiometrics *struct {
		// Fields Form Field or App fields like textField
		Fields *[]struct {
			// HesitationPercentage hesitation percentage in fields
			HesitationPercentage *float32 `json:"hesitationPercentage,omitempty"`

			// IsLTM is field in long term memory
			IsLTM *bool `json:"isLTM,omitempty"`

			// Name name of the Web form field
			Name *string `json:"name,omitempty"`

			// NumAutoFillEvents Number of Autfill events
			NumAutoFillEvents *float32 `json:"numAutoFillEvents,omitempty"`

			// NumClipboardEvents Number of copy paste events
			NumClipboardEvents *float32 `json:"numClipboardEvents,omitempty"`

			// NumCopyPasteEvents Number of copy paste events
			NumCopyPasteEvents *float32 `json:"numCopyPasteEvents,omitempty"`

			// NumExpertKeyEvents Number of Expert Key Events
			NumExpertKeyEvents *float32 `json:"numExpertKeyEvents,omitempty"`

			// TimeSpendInMsEvents time spent in MS in that field
			TimeSpendInMsEvents *[]int64 `json:"timeSpendInMsEvents,omitempty"`
		} `json:"fields,omitempty"`

		// HesitationPercentile hesitation percentile Object
		HesitationPercentile *struct {
			// Ltm Fields like Name, address which are in long term memory. Long term memory are fields like name, address which is usually memorized by the users.
			Ltm *float32 `json:"ltm,omitempty"`

			// NonLtm Fields like Amount which are not in long term memory.Fields like Amount, Quantity and sometimes credit card number are not fields that folks normally memorize and hence are put in non long term memory.
			NonLtm *float32 `json:"nonLtm,omitempty"`
		} `json:"hesitationPercentile,omitempty"`

		// NumDistractionEvents Number of Distractions Events
		NumDistractionEvents *float32 `json:"numDistractionEvents,omitempty"`
	} `json:"behaviorBiometrics,omitempty"`

	// Bot The bot score of the device.
	Bot *struct {
		// Level Riskiness of the bot session: "very_high", "high", "medium" or "low"
		Level *string `json:"level,omitempty"`
	} `json:"bot,omitempty"`

	// Checkpoints Result of rule evaluations for each checkpoint. `device` checkpoint is executed by default.
	Checkpoints *DeviceCheckpointsResponse `json:"checkpoints,omitempty"`

	// DeviceReputation Reputation of the device across our network (eg if we have seen any fraud report for this device): "very_high_risk", "high_risk", "medium_risk", "low_medium_risk", "low_risk" or "unknown"
	DeviceReputation *string `json:"deviceReputation,omitempty"`

	// Fingerprint Fingerprint of the device/browser at a global level, also known as SoftID or FuzzyID, based on a hash of different attributes on the device. There can be overlap, hence the related fingerprintConfidenceScore.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// FingerprintConfidenceScore confidence of fingerprint being unique from 0 to 100
	FingerprintConfidenceScore *int `json:"fingerprintConfidenceScore,omitempty"`

	// GpsLocation Location data got from GPS coordinate (available only if your application has user's permission to collect user's location)
	GpsLocation *struct {
		// City City
		City *string `json:"city,omitempty"`

		// Country Country
		Country *string `json:"country,omitempty"`

		// Latitude latitude
		Latitude *string `json:"latitude,omitempty"`

		// Longitude longitude
		Longitude *string `json:"longitude,omitempty"`

		// Region Region/State
		Region *string `json:"region,omitempty"`
	} `json:"gpsLocation,omitempty"`

	// Id Device ID. Also known as HardID or ExactID. This is a cookie that is placed on the customer's browser.
	Id *string `json:"id,omitempty"`

	// IpLocation Location data got from IP Address
	IpLocation *struct {
		// City City from IP
		City *string `json:"city,omitempty"`

		// Country Country from IP
		Country *string `json:"country,omitempty"`

		// Latitude latitude from IP
		Latitude *string `json:"latitude,omitempty"`

		// Longitude longitude from IP
		Longitude *string `json:"longitude,omitempty"`

		// Region Region/State from IP
		Region *string `json:"region,omitempty"`
	} `json:"ipLocation,omitempty"`

	// Level Riskiness of the device session: "very_high", "high", "medium", or "low". This is computed using device checkpoint.
	Level *string `json:"level,omitempty"`

	// SessionKey Session Key
	SessionKey *string `json:"sessionKey,omitempty"`

	// Signals | Name | Description |Values|
	// |--------|---------|-----------|
	// | TrueOS | True OS of device e.g.  BlueStacks Android Emulator running on Mac will get TrueOS of Mac instead of Android. |Windows, Linux/Android, Mac/iOS, Unknown|
	// | OSAnomaly| Likelihood of OS anomaly between the TrueOS  vs OS sent by the device|high/medium/low |
	// | DeviceAgeHours | Hours since we have first seen the device. | 1|
	// | TrueIP | True IP Address behind IP masking tools |Sample Value: 127.0.0.1|
	// | VPN | The likelihood of the network connection being a VPN| "high", "medium", or "low" |
	// | Proxy | The likelihood of network connection being a Proxy  | "high", "medium", or "low" |
	// | Emulator | Is the device  an emulator eg [Bluestacks](https://www.bluestacks.com/) - Android, Selenium - Web | true/false |
	// | Rooted | Is the device rooted? (mobile SDK only) | true/false |
	// | RemoteSoftwareLevel | Is the device  controlled via Remote Software like TeamViewer, AnyDesk, etc ?| high/medium/low |
	// | IpType | Ip address  type |"Commercial", "Organization","Government", "Military", "Education", "Library", "Fixed Line ISP", "Mobile ISP", "Data Center", "Fixed Line ISP / Mobile ISP", "Invalid IP" and "Unknown" |
	// | AccountDeviceId | Account level device ID that is resistant to minor changes; fingerprint at the user account level to help with login anomalies |123|
	// | behaviorBiometricLevel | Riskiness from behavior|high/medium/low|
	Signals *[]struct {
		// Key Key of the signal
		Key *string `json:"key,omitempty"`

		// Value value of the signal
		Value *string `json:"value,omitempty"`
	} `json:"signals,omitempty"`
}

// Feedback Feedback
type Feedback struct {
	// Action Actions to be taken on the entities in the feedback.
	Action *struct {
		// Blocklist Indicates if the user and their information should be blocklisted as a result of this feedback, regardless of fraudulent status (for a TOS violation, for example).
		Blocklist *bool `json:"blocklist,omitempty"`
	} `json:"action,omitempty"`

	// Description Free-form text to explain feedback
	Description *string `json:"description,omitempty"`

	// DisputeStatus Status of chargeback dispute from the end customer perspective, i.e., not the merchant or bank perspective
	DisputeStatus *FeedbackDisputeStatus `json:"disputeStatus,omitempty"`

	// Id Unique identifier for this feedback event. For example, in the case of multiple partial chargebacks, this would be the id of that particular chargeback
	Id *string `json:"id,omitempty"`

	// IsFraudulent Indicates the feedback is for a fradulent transaction. If false or omitted, fraud status will be derived from the info sent on the type, status, and reason fields.
	IsFraudulent *bool `json:"isFraudulent,omitempty"`

	// Processor Processor name, e.g., Stripe, WorldPay
	Processor *string `json:"processor,omitempty"`

	// Reason Reason code that defines the reason for feedback, such as ACH code (eg. R10), processor declined code, or chargeback code
	Reason *string `json:"reason,omitempty"`

	// ReviewedBy The user id or email of the analyst who manually reviewed this transaction. <b>Used only when feedback.type is set to "manual_review".</b>
	ReviewedBy *string `json:"reviewedBy,omitempty"`

	// Scope Scope of the Feedback. Pass "session" in cases of ATO where the user is still good, but session is fraudulent OR pass "user" in case the user is fraudulent. Default scope is "user".
	Scope *FeedbackScope `json:"scope,omitempty"`

	// Status Status of feedback, dependent on *type*, One of the following. Refer to [guide](/guides/integration/integrationGuides/feedbackData/feedbackIntegration#feedback-api-integration) for details.
	Status *FeedbackStatus `json:"status,omitempty"`

	// TimeMillis Approximate time the merchant knew about chargeback status like fraud OR the time the authorization was sent
	TimeMillis *int64 `json:"timeMillis,omitempty"`

	// Type Type of feedback will be one of the following.
	Type *FeedbackType `json:"type,omitempty"`
}

// FeedbackDisputeStatus Status of chargeback dispute from the end customer perspective, i.e., not the merchant or bank perspective
type FeedbackDisputeStatus string

// FeedbackScope Scope of the Feedback. Pass "session" in cases of ATO where the user is still good, but session is fraudulent OR pass "user" in case the user is fraudulent. Default scope is "user".
type FeedbackScope string

// FeedbackStatus Status of feedback, dependent on *type*, One of the following. Refer to [guide](/guides/integration/integrationGuides/feedbackData/feedbackIntegration#feedback-api-integration) for details.
type FeedbackStatus string

// FeedbackType Type of feedback will be one of the following.
type FeedbackType string

// Flow identifies the current user flow such as onboarding, login or payment
type Flow struct {
	// CreatedAtMillis The timestamp in milliseconds of the event. This is only used when sending past event data (e.g. backfill) to specify the timestamp of that original event. You should omit this field for real-time events integrations.
	CreatedAtMillis *int64 `json:"createdAtMillis,omitempty"`

	// Id Unique identifier for this flow event
	Id *string `json:"id,omitempty"`

	// Name Name of the event
	Name *string `json:"name,omitempty"`

	// Type The type of category event this request is for
	Type *FlowType `json:"type,omitempty"`
}

// FlowType The type of category event this request is for
type FlowType string

// IdDocument document used for ID verification such as passport or driver's license
type IdDocument struct {
	// Country issuing country
	Country *string `json:"country,omitempty"`

	// Number number of ID
	Number string `json:"number"`

	// State issuing state
	State *string `json:"state,omitempty"`

	// Type Type of document: passport, driver_license or other
	Type string `json:"type"`
}

// ListItems list_items object.
type ListItems struct {
	// ClientId Sardine client identifier for the account the listed item belongs to.
	ClientId *string `json:"client_id,omitempty"`

	// Comment Optional comment provided when item was added to the custom list.
	Comment *string `json:"comment,omitempty"`

	// Expiry This field is a millisecond unix timestamp which tells when this item expires from the custom list.
	Expiry *float32 `json:"expiry,omitempty"`

	// Id Sardine internal identifier for listed item.
	Id *int `json:"id,omitempty"`

	// ListId Sardine internal identifier for the custom list the item belongs to.
	ListId *int `json:"list_id,omitempty"`

	// Value The value of the custom listed item.
	Value *string `json:"value,omitempty"`
}

// MXData List of JSON you get from MX APIs
type MXData struct {
	// AccountOwnersResponse JSON containing HTTP response from MX `GET /users/{user_guid}/members/{member_guid}/account_owners` get API. Reference:https://docs.mx.com/api#identification_identity_list_account_owners. We require bank accounts of each {member_guid} which will be used to make ach transactions.
	AccountOwnersResponse *map[string]interface{} `json:"accountOwnersResponse,omitempty"`

	// AccountsResponse JSON containing HTTP response from MX `GET /users/{user_guid}/accounts` get API. Reference:https://docs.mx.com/api#core_resources_accounts_list_accounts. We require all page of results to be returned in the response either in a single response or in multiple responses.
	AccountsResponse *map[string]interface{} `json:"accountsResponse,omitempty"`

	// ListAccountNumbersResponse JSON containing HTTP response from MX `GET /users/{user_guid}/members/{member_guid}/account_numbers` get API. Reference:https://docs.mx.com/verification/guides/api_flow#list_account_numbers. We require bank accounts of each {member_guid} which will be used to make ach transactions. This API is required connect account number and routing number used for ach transactions.
	ListAccountNumbersResponse *map[string]interface{} `json:"listAccountNumbersResponse,omitempty"`

	// TransactionsResponse JSON containing HTTP response from MX `GET /users/{user_guid}/accounts/{account_guid}/transactions` get API. Reference:https://docs.mx.com/api#core_resources_transactions_list_transactions_by_account. We require all page of results to be returned in the response either in a single response or in multiple responses.
	TransactionsResponse *map[string]interface{} `json:"transactionsResponse,omitempty"`
}

// OtherPaymentMethod Other payment method
type OtherPaymentMethod struct {
	ExtraData *map[string]interface{} `json:"extraData,omitempty"`

	// Id ID of payment method
	Id string `json:"id"`

	// IsVerified If payment method has been verified by 2fA (for example, sending small amount authorization to card and asking user to confirm authorization details)
	IsVerified *bool `json:"isVerified,omitempty"`

	// Type Type of payment method, e.g., paypal, applepay, googlepay, samsungpay, etc.
	Type string `json:"type"`
}

// PaymentMethod Payment Method
type PaymentMethod struct {
	// Bank Bank account details
	Bank *Bank `json:"bank,omitempty"`

	// BillingAddress Address
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// Card Card information
	Card *Card `json:"card,omitempty"`

	// Crypto Crypto address
	Crypto     *Crypto `json:"crypto,omitempty"`
	FirstName  *string `json:"firstName,omitempty"`
	LastName   *string `json:"lastName,omitempty"`
	MiddleName *string `json:"middleName,omitempty"`

	// Other Other payment method
	Other *OtherPaymentMethod `json:"other,omitempty"`

	// Type Must be one of the following:
	Type   PaymentMethodType `json:"type"`
	Wallet *Wallet           `json:"wallet,omitempty"`

	// Wire Bank account details
	Wire *Wire `json:"wire,omitempty"`
}

// PaymentMethodType Must be one of the following:
type PaymentMethodType string

// PersonalInfo Personal information obtained via third-party external to Sardine
type PersonalInfo struct {
	// Address Address
	Address *Address `json:"address,omitempty"`

	// DateOfBirth The date of birth in format YYYY-MM-DD
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	EmailAddress *string `json:"emailAddress,omitempty"`
	FirstName    *string `json:"firstName,omitempty"`

	// IdDocument document used for ID verification such as passport or driver's license
	IdDocument *IdDocument `json:"idDocument,omitempty"`

	// IdentityObject Dump of data you receive from third party provider. For instance if you use plaid for bank verification, please pass us JSON value of [plaid's identity object](https://plaid.com/docs/api/products/#identity)
	IdentityObject *string `json:"identityObject,omitempty"`

	// IsEmailVerified true if email is verified
	IsEmailVerified *bool `json:"isEmailVerified,omitempty"`

	// IsKycVerified If user has been verified via KYC process
	IsKycVerified *bool `json:"isKycVerified,omitempty"`

	// IsPhoneVerified true if phone number is verified
	IsPhoneVerified *bool   `json:"isPhoneVerified,omitempty"`
	LastName        *string `json:"lastName,omitempty"`
	MiddleName      *string `json:"middleName,omitempty"`

	// Nationality Nationality of the person
	Nationality *string `json:"nationality,omitempty"`

	// Phone The customer's phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
	Phone *string `json:"phone,omitempty"`

	// Source Source of personal information obtained via external third-party (non-Sardine) for verification. Discuss with Sardine before using. *MUST* be one of the following:
	Source *PersonalInfoSource `json:"source,omitempty"`
}

// PersonalInfoSource Source of personal information obtained via external third-party (non-Sardine) for verification. Discuss with Sardine before using. *MUST* be one of the following:
type PersonalInfoSource string

// PersonalInfoAndPaymentMethod defines model for PersonalInfoAndPaymentMethod.
type PersonalInfoAndPaymentMethod struct {
	// Address Address
	Address *Address `json:"address,omitempty"`

	// DateOfBirth The date of birth in format YYYY-MM-DD
	DateOfBirth  *string `json:"dateOfBirth,omitempty"`
	EmailAddress *string `json:"emailAddress,omitempty"`
	FirstName    *string `json:"firstName,omitempty"`

	// IdDocument document used for ID verification such as passport or driver's license
	IdDocument *IdDocument `json:"idDocument,omitempty"`

	// IdentityObject Dump of data you receive from third party provider. For instance if you use plaid for bank verification, please pass us JSON value of [plaid's identity object](https://plaid.com/docs/api/products/#identity)
	IdentityObject *string `json:"identityObject,omitempty"`

	// IsEmailVerified true if email is verified
	IsEmailVerified *bool `json:"isEmailVerified,omitempty"`

	// IsKycVerified If user has been verified via KYC process
	IsKycVerified *bool `json:"isKycVerified,omitempty"`

	// IsPhoneVerified true if phone number is verified
	IsPhoneVerified *bool   `json:"isPhoneVerified,omitempty"`
	LastName        *string `json:"lastName,omitempty"`
	MiddleName      *string `json:"middleName,omitempty"`

	// Nationality Nationality of the person
	Nationality *string `json:"nationality,omitempty"`

	// PaymentMethod Payment Method
	PaymentMethod *PaymentMethod `json:"paymentMethod,omitempty"`

	// Phone The customer's phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
	Phone *string `json:"phone,omitempty"`

	// Source Source of personal information obtained via external third-party (non-Sardine) for verification. Discuss with Sardine before using. *MUST* be one of the following:
	Source *PersonalInfoAndPaymentMethodSource `json:"source,omitempty"`

	// Tags List of tags associated with the counterparty entity.
	Tags *[]Tags `json:"tags,omitempty"`
}

// PersonalInfoAndPaymentMethodSource Source of personal information obtained via external third-party (non-Sardine) for verification. Discuss with Sardine before using. *MUST* be one of the following:
type PersonalInfoAndPaymentMethodSource string

// ReferralCode Referral code
type ReferralCode struct {
	// Amount amount tied to the referral
	Amount *float32 `json:"amount,omitempty"`

	// Code The referral code used for this event by the customer
	Code *string `json:"code,omitempty"`

	// CurrencyCode currency code for the amount tied to the referral
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// IssuerId ID of user who issued the referral code used by the customer
	IssuerId *string `json:"issuerId,omitempty"`
}

// ResponsePaymentMethod defines model for ResponsePaymentMethod.
type ResponsePaymentMethod struct {
	Card *struct {
		IdentityMatch *struct {
			// BillingAddress Returns whether the billing address on file with the issuer on card matches the name provided by the customer.
			BillingAddress *ResponsePaymentMethodCardIdentityMatchBillingAddress `json:"billingAddress,omitempty"`

			// DateOfBirth Returns whether the date of birth on file with the issuer on card matches the name provided by the customer.
			DateOfBirth *ResponsePaymentMethodCardIdentityMatchDateOfBirth `json:"dateOfBirth,omitempty"`

			// EmailAddress Returns whether the email address on file with the issuer on card matches the name provided by the customer.
			EmailAddress *ResponsePaymentMethodCardIdentityMatchEmailAddress `json:"emailAddress,omitempty"`

			// FullName Returns whether the full name on file with the issuer on card matches the name provided by the customer.
			FullName *ResponsePaymentMethodCardIdentityMatchFullName `json:"fullName,omitempty"`

			// Phone Returns whether the phone number on file with the issuer on card matches the name provided by the customer.
			Phone *ResponsePaymentMethodCardIdentityMatchPhone `json:"phone,omitempty"`

			// PostalCode Returns whether the zip code on file with the issuer on card matches the name provided by the customer.
			PostalCode *ResponsePaymentMethodCardIdentityMatchPostalCode `json:"postalCode,omitempty"`

			// ShippingAddress Returns whether the shipping address on file with the issuer on card matches the name provided by the customer.
			ShippingAddress *ResponsePaymentMethodCardIdentityMatchShippingAddress `json:"shippingAddress,omitempty"`
		} `json:"identityMatch,omitempty"`
	} `json:"card,omitempty"`
}

// ResponsePaymentMethodCardIdentityMatchBillingAddress Returns whether the billing address on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchBillingAddress string

// ResponsePaymentMethodCardIdentityMatchDateOfBirth Returns whether the date of birth on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchDateOfBirth string

// ResponsePaymentMethodCardIdentityMatchEmailAddress Returns whether the email address on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchEmailAddress string

// ResponsePaymentMethodCardIdentityMatchFullName Returns whether the full name on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchFullName string

// ResponsePaymentMethodCardIdentityMatchPhone Returns whether the phone number on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchPhone string

// ResponsePaymentMethodCardIdentityMatchPostalCode Returns whether the zip code on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchPostalCode string

// ResponsePaymentMethodCardIdentityMatchShippingAddress Returns whether the shipping address on file with the issuer on card matches the name provided by the customer.
type ResponsePaymentMethodCardIdentityMatchShippingAddress string

// Rules defines model for Rules.
type Rules struct {
	Actions *[]struct {
		ActionType *string `json:"actionType,omitempty"`
		Key        *string `json:"key,omitempty"`
		Value      *string `json:"value,omitempty"`
	} `json:"actions,omitempty"`

	// Checkpoint Name of the checkpoint the rule is tied to
	Checkpoint *string `json:"checkpoint,omitempty"`

	// ClientID Sardine clientID to which rule belongs to
	ClientID *string `json:"clientID,omitempty"`

	// Condition Condition the rule is checking for
	Condition *string `json:"condition,omitempty"`

	// CreatedAt Timestamp when case was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// Description Description of the rule
	Description *string `json:"description,omitempty"`

	// Enforced If the rule is enforced by the parent account
	Enforced *bool `json:"enforced,omitempty"`

	// Id Sardine identifier for the rule
	Id *int64 `json:"id,omitempty"`

	// IsDefault Indicates if the rule is a default rule provided by Sardine
	IsDefault *bool `json:"isDefault,omitempty"`

	// IsShadow Indicates if the rule is a shadow rule
	IsShadow *bool `json:"isShadow,omitempty"`

	// Name Name of the rule
	Name *string `json:"name,omitempty"`

	// RuleOrder Order of the rule execution within the checkpoint
	RuleOrder *int `json:"ruleOrder,omitempty"`

	// UpdatedAt Timestamp when case was last updated
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

// RulesResponse List of live and shadow rules that triggered for this session
type RulesResponse = []struct {
	// Id Identifier of the rule that triggered on this session
	Id *int `json:"id,omitempty"`

	// IsAllowlisted Flag indicating if the rule has been allowlisted
	IsAllowlisted *bool `json:"isAllowlisted,omitempty"`

	// IsLive Flag indicating if the rule was live when triggered on this session
	IsLive *bool `json:"isLive,omitempty"`

	// Name Name of the rule as set in the Sardine dashboard
	Name *string `json:"name,omitempty"`

	// Score Score assigned to the rule. Only returned for Score Sum type rules
	Score *int `json:"score,omitempty"`
}

// Signal defines model for Signal.
type Signal struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Source Source is where people can add metadata about the company they have.
type Source struct {
	// Metadata Source
	Metadata struct {
		// FileNumber number provided to you when you register the company
		FileNumber *string `json:"fileNumber,omitempty"`

		// RegionCode The state or region for the customer. For USA and Canada, state code in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) code (e.g. CA) is required
		RegionCode *string               `json:"regionCode,omitempty"`
		Status     *SourceMetadataStatus `json:"status,omitempty"`
	} `json:"metadata"`
	Type SourceType `json:"type"`
}

// SourceMetadataStatus defines model for Source.Metadata.Status.
type SourceMetadataStatus string

// SourceType defines model for Source.Type.
type SourceType string

// StripeData List of JSON you get from Stripe Financial connections APIs
type StripeData struct {
	// AccountNumber Account number of the bank account. This field is required only for the first time. After that, we will use the account id to retrieve the account number information. We will link the stripe account id to the mapped account number and routing number in our database.
	AccountNumber *string `json:"accountNumber,omitempty"`

	// AccountsResponse JSON containing HTTP response from Stripe Financial connections `GET/v1/financial_connections/accounts/:id`, `POST/v1/financial_connections/accounts/:id/refresh`. Balance and ownership information can be retrieved from the accounts API at the stripe account id level. Ownership information only needs to be sent once ever per account; in contrast, for each new ACH transaction, always send the latest balance information. The latest balance can be retrieved through the refresh feature. Reference: https://stripe.com/docs/api/financial_connections/accounts and https://stripe.com/docs/api/financial_connections/accounts/refresh#financial_connections_refresh_account-features.
	AccountsResponse *map[string]interface{} `json:"accountsResponse,omitempty"`

	// RoutingNumber Routing number of the bank account. This field is required only for the first time. After that, we will use the account id to retrieve the routing number information. We will link the stripe account id to the mapped account number and routing number in our database.
	RoutingNumber *string `json:"routingNumber,omitempty"`

	// TransactionsResponse JSON containing a list of transactions (in JSON format) from Stripe Financial connections. The list of transactions is specific to the stripe account id level. We require all pages of results to be returned in the response either in a single response or in multiple responses
	TransactionsResponse *map[string]interface{} `json:"transactionsResponse,omitempty"`
}

// Tags Custom tag information for a given entity.
type Tags struct {
	// Name Tag name, may contain alphanumeric characters and underscores only.
	Name *string `json:"name,omitempty"`

	// Type Tag value type. String and level are both strings, score and int are integer numbers and float is a floating number.
	Type *TagsType `json:"type,omitempty"`

	// Value Tag value to save. May be a string or number (integer or float).
	Value *map[string]interface{} `json:"value,omitempty"`
}

// TagsType Tag value type. String and level are both strings, score and int are integer numbers and float is a floating number.
type TagsType string

// TellerData List of JSON you get from Teller APIs
type TellerData struct {
	// AccountNumber Account number of the bank account. This field is required only for the first time. After that, we will use the account id to retrieve the account number information. We will link the teller account id to the mapped account number and routing number in our database.
	AccountNumber   *string                 `json:"accountNumber,omitempty"`
	AccountResponse *map[string]interface{} `json:"accountResponse,omitempty"`

	// BalanceResponse Teller's Account Balance API response.
	BalanceResponse *map[string]interface{} `json:"balanceResponse,omitempty"`

	// RoutingNumber Routing number of the bank account. This field is required only for the first time. After that, we will use the account id to retrieve the routing number information. We will link the teller account id to the mapped account number and routing number in our database.
	RoutingNumber *string `json:"routingNumber,omitempty"`

	// TransactionsResponse Teller's transaction API response.
	TransactionsResponse *map[string]interface{} `json:"transactionsResponse,omitempty"`
}

// Transaction Transaction
type Transaction struct {
	// ActionType Indicates the type of transaction. It is used to determine the direction of the money movement from the customer perspective as outward (buy, withdraw, transfer, loanRepayment, multiParty, exchange (if paymentMethodType!=crypto)) or inward (sell, deposit, topup, refund, loanFunding, exchange (if paymentMethodType==crypto)). If omitted, Sardine considers the transaction as an outward money movement.
	ActionType *TransactionActionType `json:"actionType,omitempty"`

	// Amount Amount of transaction, it can only be zero in the case of a $0 card auth. In the case of adding/linking a card or bank account, omit this field altogether. **Note**: This is a float number in major units (e.g. dollar amount for USD)
	Amount *float32 `json:"amount,omitempty"`

	// CreatedAtMillis Unix timestamp in milliseconds
	CreatedAtMillis *int64 `json:"createdAtMillis,omitempty"`

	// CurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// Id ID of the transaction (defined by merchant) e.g. Order Number
	Id string `json:"id"`

	// IsOutward Indicates whether this transaction is considered inward or outward as it relates to aggregations. Please consult with Sardine prior to implementing this field.
	IsOutward *bool `json:"isOutward,omitempty"`

	// ItemCategory Main item category in cart.  e.g. crypto asset(ETH, BTC), gift card, alcohol, generic
	ItemCategory *string `json:"itemCategory,omitempty"`
	Items        *[]struct {
		// IsItemDigital Is this a digital or physical good
		IsItemDigital *bool `json:"isItemDigital,omitempty"`

		// ItemCategory The category of the item, e.g., ELECTRONICS, ALCOHOL, etc.
		ItemCategory *string `json:"itemCategory,omitempty"`

		// ItemName Name of the item
		ItemName *string `json:"itemName,omitempty"`

		// ItemQuantity Quantity of items
		ItemQuantity *int `json:"itemQuantity,omitempty"`

		// ItemSku SKU of item
		ItemSku *string `json:"itemSku,omitempty"`

		// ItemTotalPrice Total price for all items
		ItemTotalPrice *float32 `json:"itemTotalPrice,omitempty"`

		// ItemUnitPrice Unit price of item
		ItemUnitPrice *float32 `json:"itemUnitPrice,omitempty"`

		// ItemUrl Full URL to the item listing
		ItemUrl *string `json:"itemUrl,omitempty"`
	} `json:"items,omitempty"`

	// Mcc mcc (merchant category code) for this transaction
	Mcc *string `json:"mcc,omitempty"`

	// Note Note associated with the transaction.
	Note *string `json:"note,omitempty"`

	// PaymentMethod Payment Method
	PaymentMethod *PaymentMethod `json:"paymentMethod,omitempty"`
	Promotions    *[]struct {
		// Category The promotion category
		Category *TransactionPromotionsCategory `json:"category,omitempty"`

		// Code The code that the user input
		Code *string `json:"code,omitempty"`

		// Description The text description of this promotion code
		Description *string `json:"description,omitempty"`
		Discount    *struct {
			// Amount The amount of the discount
			Amount *float32 `json:"amount,omitempty"`

			// CurrencyCode The currency code for the discount amount
			CurrencyCode *string `json:"currencyCode,omitempty"`
		} `json:"discount,omitempty"`

		// Type The promotion discount type
		Type *TransactionPromotionsType `json:"type,omitempty"`
	} `json:"promotions,omitempty"`

	// ReceivedAmount amount received by the receiver
	ReceivedAmount *float32 `json:"receivedAmount,omitempty"`

	// ReceivedCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code for the receiver
	ReceivedCurrencyCode *string `json:"receivedCurrencyCode,omitempty"`

	// SentAmount amount sent by the sender
	SentAmount *float32 `json:"sentAmount,omitempty"`

	// SentCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code for the sender
	SentCurrencyCode *string `json:"sentCurrencyCode,omitempty"`

	// ShippingAddress Address
	ShippingAddress *Address `json:"shippingAddress,omitempty"`
	ShippingMethods *[]struct {
		// Carrier Shipping method carrier
		Carrier *string `json:"carrier,omitempty"`

		// FulfillmentMethod How is this being fulfilled, e.g., delivery vs. pickup
		FulfillmentMethod *string `json:"fulfillmentMethod,omitempty"`

		// MaxDeliveryTimeMillis Latest delivery time
		MaxDeliveryTimeMillis *int64 `json:"maxDeliveryTimeMillis,omitempty"`

		// MinDeliveryTimeMillis Earliest delivery time
		MinDeliveryTimeMillis *int64 `json:"minDeliveryTimeMillis,omitempty"`

		// Price The cost of this shipping method
		Price *float32 `json:"price,omitempty"`

		// Title Name of the shipping method
		Title *string `json:"title,omitempty"`

		// TrackingNumber Carrier-provided tracking number
		TrackingNumber *string `json:"trackingNumber,omitempty"`
	} `json:"shippingMethods,omitempty"`

	// Status status of transaction. pending, accepted, denied_fraud or denied. Default is pending.
	Status *string `json:"status,omitempty"`

	// SubscriptionId subscription ID for this recurring payment
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

// TransactionActionType Indicates the type of transaction. It is used to determine the direction of the money movement from the customer perspective as outward (buy, withdraw, transfer, loanRepayment, multiParty, exchange (if paymentMethodType!=crypto)) or inward (sell, deposit, topup, refund, loanFunding, exchange (if paymentMethodType==crypto)). If omitted, Sardine considers the transaction as an outward money movement.
type TransactionActionType string

// TransactionPromotionsCategory The promotion category
type TransactionPromotionsCategory string

// TransactionPromotionsType The promotion discount type
type TransactionPromotionsType string

// TransactionResponse transaction related information
type TransactionResponse struct {
	// AmlLevel aml risk level
	AmlLevel *string `json:"amlLevel,omitempty"`

	// Indemnification Information about transaction indemnification. This field is only set if you're utilizing sardine's transaction indemnification. Please look at the bottom of ACH Indemnification page https://docs.sardine.ai/products_solutions/achindemnification/ to see how the indemnification fields are calculated.
	Indemnification *struct {
		// Conditions List of conditions that needs to be satified in order for the transaction to be approved.
		//
		// Possible values are:
		//  - kyc: perform kyc for the user
		//  - card2fa: perform "card 2FA" by creating small amount of authorization and asking end user to confirm the authorization details
		//  - phone: perform phone verification via SMS or phone call
		//
		//  - 3ds: perform 3D secure
		Conditions *[]string `json:"conditions,omitempty"`

		// Decision Whether transaction is approved. `approved`, `conditionally_approved`, `rejected` or `unknown`. If value is `conditionally_approved`, please refer to "conditions" field to satify all conditions.
		Decision *string `json:"decision,omitempty"`

		// HoldAmount This is the remaining amount in cents that is available after the hold time is over. The hold time + instantAmount is the total  deposit amount.
		HoldAmount *float32 `json:"holdAmount,omitempty"`

		// HoldTime UNIX timestamp that represents time until you which should hold part of funds
		HoldTime *int64 `json:"holdTime,omitempty"`

		// InstantAmount This is the withdrawal amount in cents that is immediately available to the end-user. The remaining hold amount should be kept on hold on your side until the time specified by holdTime parameter below.
		InstantAmount *float32 `json:"instantAmount,omitempty"`
	} `json:"indemnification,omitempty"`

	// Level transaction risk level
	Level         *string                `json:"level,omitempty"`
	PaymentMethod *ResponsePaymentMethod `json:"paymentMethod,omitempty"`
}

// TransactionWithAuthFeedback transaction-level detail, e.g., transaction ID, to tie feedback to an existing transaction
type TransactionWithAuthFeedback struct {
	// Amount Amount of transaction for feedback, cannot be zero
	Amount *float32 `json:"amount,omitempty"`

	// CreditCardAuthorization Information you get as part of credit card authorization
	CreditCardAuthorization *CreditCardAuthorization `json:"creditCardAuthorization,omitempty"`

	// Id ID of the transaction (defined by merchant) e.g. Order Number. Required for payment transactions.
	Id *string `json:"id,omitempty"`
}

// Wallet defines model for Wallet.
type Wallet struct {
	// Id This is an enum with the following values
	Id *string `json:"id,omitempty"`

	// Token This is the actual token value for this particular wallet. This would be the Device Account Number (DAN) for Apple Pay, Virtual Account Number for Google Pay, and Digital Card Number for Samsung Pay.
	Token *string `json:"token,omitempty"`

	// TokenBin This is the BIN value of the token, could be the first 6 or 8, depending on the card.
	TokenBin *string `json:"tokenBin,omitempty"`

	// TokenBrand Brand of card in lowercase. Example values: visa, mastercard, amex.
	TokenBrand *string `json:"tokenBrand,omitempty"`

	// TokenLast4 This is the last four digits of the token.
	TokenLast4 *string `json:"tokenLast4,omitempty"`

	// Type This is an enum with the following values:
	Type *WalletType `json:"type,omitempty"`
}

// WalletType This is an enum with the following values:
type WalletType string

// Wire Bank account details
type Wire struct {
	// AccountNumber bank account number
	AccountNumber string `json:"accountNumber"`

	// Balance last known bank balance in fractional units like cents
	Balance *float32 `json:"balance,omitempty"`

	// BalanceCurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code
	BalanceCurrencyCode *string `json:"balanceCurrencyCode,omitempty"`

	// BankName name of the bank
	BankName *string `json:"bankName,omitempty"`

	// Iban International Bank Account Number
	Iban *string `json:"iban,omitempty"`

	// RoutingCode bank routing code(IRC)
	RoutingCode *string `json:"routingCode,omitempty"`

	// SwiftCode Swift Code
	SwiftCode *string `json:"swiftCode,omitempty"`

	// TransferType international_wire, domestic_wire
	TransferType *string `json:"transferType,omitempty"`
}

// CheckpointDataResponse List of checkpoints run for this session
type CheckpointDataResponse = []struct {
	// Name Name of the checkpoint
	Name *string `json:"name,omitempty"`

	// Score Total score from all live rules triggered in the checkpoint. Only returned for weighted_sum type checkpoints
	Score *int `json:"score,omitempty"`

	// Type Type of the checkpoint
	Type *CheckpointDataResponseType `json:"type,omitempty"`
}

// CheckpointDataResponseType Type of the checkpoint
type CheckpointDataResponseType string

// WorkflowResponse workflow excecution output data if a workflowName was provided in the request
type WorkflowResponse struct {
	// EndTags object with all action tags and their values from the executed worfklow end tag
	EndTags *struct {
		// AdditionalProperties key name of the action tag tied to the executed workflow end tag
		AdditionalProperties *struct {
			// Value value of the action tag tied to the executed workflow end tag
			Value *string `json:"value,omitempty"`
		} `json:"additionalProperties,omitempty"`
	} `json:"endTags,omitempty"`

	// ExecutionSequence list of all the nodes executed in sequence from the workflow
	ExecutionSequence *[]string `json:"executionSequence,omitempty"`
}

// PostPlaidProcessorTokenJSONBody defines parameters for PostPlaidProcessorToken.
type PostPlaidProcessorTokenJSONBody struct {
	// Accounts An array of processor token account objects.
	Accounts []struct {
		// AccountId The unique identifier of the account for the customer as provided by Plaid.
		AccountId string `json:"accountId"`

		// ProcessorToken The processor token for the account as provided by Plaid.
		ProcessorToken string `json:"processorToken"`
	} `json:"accounts"`

	// CustomerId Your unique identifier for this customer.
	CustomerId string `json:"customerId"`
}

// PlaidDataSyncJSONBody defines parameters for PlaidDataSync.
type PlaidDataSyncJSONBody struct {
	// AccountId The unique identifier of the account for the customer as provided by Plaid.
	AccountId string `json:"accountId"`

	// CustomerId Your unique identifier for this customer.
	CustomerId string `json:"customerId"`

	// Scope The scope of the data sync request. It must be just one of the enumerated values.
	Scope PlaidDataSyncJSONBodyScope `json:"scope"`
}

// PlaidDataSyncJSONBodyScope defines parameters for PlaidDataSync.
type PlaidDataSyncJSONBodyScope string

// GetAllowlistClientParams defines parameters for GetAllowlistClient.
type GetAllowlistClientParams struct {
	// Limit The numbers of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// NextCursor id of the last element from the previous page. this result will not include this id
	NextCursor *int `form:"nextCursor,omitempty" json:"nextCursor,omitempty"`
}

// PostAllowListCreateJSONBody defines parameters for PostAllowListCreate.
type PostAllowListCreateJSONBody struct {
	Data *[]AllowListWithoutClientIDandReason `json:"data,omitempty"`
}

// PostAllowlistExpireJSONBody defines parameters for PostAllowlistExpire.
type PostAllowlistExpireJSONBody struct {
	Type *PostAllowlistExpireJSONBodyType `json:"type,omitempty"`

	// Value The value of allowlisted item to be expired.
	Value *string `json:"value,omitempty"`
}

// PostAllowlistExpireJSONBodyType defines parameters for PostAllowlistExpire.
type PostAllowlistExpireJSONBodyType string

// PostAllowlistFindJSONBody defines parameters for PostAllowlistFind.
type PostAllowlistFindJSONBody struct {
	Type *PostAllowlistFindJSONBodyType `json:"type,omitempty"`

	// Value The value of allowlisted item being searched.
	Value *string `json:"value,omitempty"`
}

// PostAllowlistFindJSONBodyType defines parameters for PostAllowlistFind.
type PostAllowlistFindJSONBodyType string

// PostBankTransactionsJSONBody defines parameters for PostBankTransactions.
type PostBankTransactionsJSONBody struct {
	// BankData Information about bank account and transaction. Please specify this field if you don't use plaid
	BankData *BankData `json:"bankData,omitempty"`

	// CustomerId Id of customer. Please use the same value you sent to [v1/customers API](/guides/api-reference/customer/evaluate-customer-sessiontransaction-risk)
	CustomerId string `json:"customerId"`

	// MxData List of JSON you get from MX APIs
	MxData *MXData `json:"mxData,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey string `json:"sessionKey"`

	// StripeData List of JSON you get from Stripe Financial connections APIs
	StripeData *StripeData `json:"stripeData,omitempty"`

	// TellerData List of JSON you get from Teller APIs
	TellerData *TellerData `json:"tellerData,omitempty"`
}

// GetClientBlocklistsParams defines parameters for GetClientBlocklists.
type GetClientBlocklistsParams struct {
	// Limit The numbers of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// NextCursor id of the last element from the previous page. this result will not include this id
	NextCursor *int `form:"nextCursor,omitempty" json:"nextCursor,omitempty"`
}

// PostClientBlocklistsJSONBody defines parameters for PostClientBlocklists.
type PostClientBlocklistsJSONBody struct {
	Data *[]BlockListWithoutClientIDandReason `json:"data,omitempty"`
}

// PostBlockListExpireJSONBody defines parameters for PostBlockListExpire.
type PostBlockListExpireJSONBody struct {
	Type *PostBlockListExpireJSONBodyType `json:"type,omitempty"`

	// Value The value of blocklisted item to be expired.
	Value *string `json:"value,omitempty"`
}

// PostBlockListExpireJSONBodyType defines parameters for PostBlockListExpire.
type PostBlockListExpireJSONBodyType string

// PostSpecificBlockListJSONBody defines parameters for PostSpecificBlockList.
type PostSpecificBlockListJSONBody struct {
	// Type The type of blocklisted item being searched.
	Type *PostSpecificBlockListJSONBodyType `json:"type,omitempty"`

	// Value The value of blocklisted item being searched.
	Value *string `json:"value,omitempty"`
}

// PostSpecificBlockListJSONBodyType defines parameters for PostSpecificBlockList.
type PostSpecificBlockListJSONBodyType string

// GetbixParams defines parameters for Getbix.
type GetbixParams struct {
	// Id Sardine identifier
	Id int `form:"id" json:"id"`
}

// UpdateBizJSONBody defines parameters for UpdateBiz.
type UpdateBizJSONBody struct {
	// Address The Business address. This is not required for the Advanced AML Screening use case.
	Address *BizAddress `json:"address,omitempty"`

	// Name new name to set for the existing business
	Name *string `json:"name,omitempty"`

	// Status new decision status to set for the existing business
	Status UpdateBizJSONBodyStatus `json:"status"`

	// TaxId new taxId to set for the existing business
	TaxId *string `json:"taxId,omitempty"`

	// Website new website to set for the existing business. This must include the http:// or https://
	Website *string `json:"website,omitempty"`
}

// UpdateBizParams defines parameters for UpdateBiz.
type UpdateBizParams struct {
	Id int64 `form:"id" json:"id"`
}

// UpdateBizJSONBodyStatus defines parameters for UpdateBiz.
type UpdateBizJSONBodyStatus string

// AddUpdateBizJSONBody defines parameters for AddUpdateBiz.
type AddUpdateBizJSONBody struct {
	Business Business   `json:"business"`
	Config   *BizConfig `json:"config,omitempty"`
}

// PostV1BusinessesScreeningPmsJSONBody defines parameters for PostV1BusinessesScreeningPms.
type PostV1BusinessesScreeningPmsJSONBody struct {
	// Cursor Cursor for pagination
	Cursor *int `json:"cursor,omitempty"`

	// End End timestamp for the search period (milliseconds since Unix epoch)
	End *int `json:"end,omitempty"`

	// Start Start timestamp for the search period (milliseconds since Unix epoch)
	Start *int `json:"start,omitempty"`
}

// GetCaseParams defines parameters for GetCase.
type GetCaseParams struct {
	// ClientId Sardine account identifier the case belongs to
	ClientId string `form:"client_id" json:"client_id"`

	// Id Sardine identifier for the case
	Id int `form:"id" json:"id"`
}

// NewCaseJSONBody defines parameters for NewCase.
type NewCaseJSONBody struct {
	// AssignedTo Sardine dashboard user the case has been assigned to
	AssignedTo *string `json:"assignedTo,omitempty"`

	// AttachedDocuments Sardine identifier of the document to link to the case
	AttachedDocuments *[]string `json:"attachedDocuments,omitempty"`

	// CaseDecision Latest decision of the case
	CaseDecision *string `json:"caseDecision,omitempty"`

	// CaseDecisionlabelId Sardine identifier for the decision label
	CaseDecisionlabelId *string `json:"caseDecisionlabelId,omitempty"`

	// CaseDescription Description of the case
	CaseDescription *string `json:"caseDescription,omitempty"`

	// CaseName Name assigned to case
	CaseName *string `json:"caseName,omitempty"`

	// CaseStatus Latest status of the case
	CaseStatus *NewCaseJSONBodyCaseStatus `json:"caseStatus,omitempty"`

	// ClientId clientId for your Sardine account
	ClientId *string `json:"clientId,omitempty"`

	// LinkedBusinesses List of business IDs this case is linked to
	LinkedBusinesses *[]string `json:"linkedBusinesses,omitempty"`

	// LinkedCustomer List of customer IDs this case is linked to
	LinkedCustomer *[]string `json:"linkedCustomer,omitempty"`

	// LinkedReviews List of review IDs this case is linked to
	LinkedReviews *[]string `json:"linkedReviews,omitempty"`

	// LinkedTransaction List of transaction IDs this case is linked to
	LinkedTransaction *[]string `json:"linkedTransaction,omitempty"`

	// Owner name of the case owner
	Owner *string `json:"owner,omitempty"`
}

// NewCaseJSONBodyCaseStatus defines parameters for NewCase.
type NewCaseJSONBodyCaseStatus string

// UpdateCaseJSONBody defines parameters for UpdateCase.
type UpdateCaseJSONBody struct {
	// AssignedTo Sardine dashboard user the case has been assigned to
	AssignedTo *string `json:"assignedTo,omitempty"`

	// AttachedDocuments Sardine identifier of the document to link to the case
	AttachedDocuments *[]string `json:"attachedDocuments,omitempty"`

	// CaseDecision Latest decision of the case
	CaseDecision *string `json:"caseDecision,omitempty"`

	// CaseDecisionlabelId Sardine identifier for the decision label
	CaseDecisionlabelId *string `json:"caseDecisionlabelId,omitempty"`

	// CaseDescription Description of the case
	CaseDescription *string `json:"caseDescription,omitempty"`

	// CaseName Name assigned to case
	CaseName *string `json:"caseName,omitempty"`

	// CaseStatus Latest status of the case
	CaseStatus *UpdateCaseJSONBodyCaseStatus `json:"caseStatus,omitempty"`

	// ExtensionTimer Indicates if timer should be extended by 30 days
	ExtensionTimer *UpdateCaseJSONBodyExtensionTimer `json:"extensionTimer,omitempty"`

	// LinkedBusinesses List of business IDs this case is linked to
	LinkedBusinesses *[]string `json:"linkedBusinesses,omitempty"`

	// LinkedCustomer List of customer IDs this case is linked to
	LinkedCustomer *[]string `json:"linkedCustomer,omitempty"`

	// LinkedReviews List of review IDs this case is linked to
	LinkedReviews *[]string `json:"linkedReviews,omitempty"`

	// LinkedTransaction List of transaction IDs this case is linked to
	LinkedTransaction *[]string `json:"linkedTransaction,omitempty"`
}

// UpdateCaseParams defines parameters for UpdateCase.
type UpdateCaseParams struct {
	// ClientId Sardine account identifier the case belongs to
	ClientId string `form:"client_id" json:"client_id"`

	// Id Sardine identifier for the case
	Id int `form:"id" json:"id"`
}

// UpdateCaseJSONBodyCaseStatus defines parameters for UpdateCase.
type UpdateCaseJSONBodyCaseStatus string

// UpdateCaseJSONBodyExtensionTimer defines parameters for UpdateCase.
type UpdateCaseJSONBodyExtensionTimer string

// PostCustomListJSONBody defines parameters for PostCustomList.
type PostCustomListJSONBody struct {
	ClientList struct {
		// Name Name of the custom list you are creating.
		Name *string `json:"name,omitempty"`
	} `json:"client_list"`

	// ClientListItems Optional items to seed the list with at creation. Pass an empty array, if you would like to create an empty custom list.
	ClientListItems []struct {
		// Comment Optional comment provided when item was added to the custom list.
		Comment *string `json:"comment,omitempty"`

		// Expiry This field is a millisecond unix timestamp which tells when this item expires from the custom list.
		Expiry *float32 `json:"expiry,omitempty"`

		// Value The value of the custom listed item.
		Value *string `json:"value,omitempty"`
	} `json:"client_list_items"`
}

// PostCustomListDeleteJSONBody defines parameters for PostCustomListDelete.
type PostCustomListDeleteJSONBody struct {
	// ClientListId Sardine internal identifier for the custom list.
	ClientListId int `json:"client_list_id"`
}

// PostNewListItemsJSONBody defines parameters for PostNewListItems.
type PostNewListItemsJSONBody struct {
	// ClientListId Sardine internal identifier for the custom list.
	ClientListId int `json:"client_list_id"`

	// ClientListItems Optional items to seed the list with at creation. Pass an empty array, if you would like to create an empty custom list.
	ClientListItems []struct {
		// Comment Optional comment provided when item was added to the custom list.
		Comment *string `json:"comment,omitempty"`

		// Expiry This field is a millisecond unix timestamp which tells when this item expires from the custom list.
		Expiry *float32 `json:"expiry,omitempty"`

		// Value The value of the custom listed item.
		Value *string `json:"value,omitempty"`
	} `json:"client_list_items"`
}

// PostItemsDeleteJSONBody defines parameters for PostItemsDelete.
type PostItemsDeleteJSONBody struct {
	// ClientListItemIds List of Sardine's internal identifier for the items to be deleted.
	ClientListItemIds []int `json:"client_list_item_ids"`
}

// PostCustomerInformationJSONBody defines parameters for PostCustomerInformation.
type PostCustomerInformationJSONBody struct {
	// Checkpoints Name of the checkpoints to be invoked. *Please discuss with Sardine.*  `customer` checkpoint will be executed by default if checkpoints array is omitted and `device` checkpoint will be run if a matching device sessionKey is found. Refer to [checkpoints](/guides/integration/developerResources/checkpoints) for recommended use cases, descriptions and prerequisites. Invalid checkpoints will return a 422 error.
	Checkpoints *[]PostCustomerInformationJSONBodyCheckpoints `json:"checkpoints,omitempty"`

	// Config Config Object. Default config values to enable/disable various Sardine functionality is done at merchant level. For some merchants, Sardine may allow overriding the default configuration. eg By default, sanction screening may be enabled for all api calls for a merchant and Sardine *may* allow selective sanction screening to be enabled via config.
	Config       *Config `json:"config,omitempty"`
	Counterparty *struct {
		// Address Address
		Address *Address `json:"address,omitempty"`

		// BusinessName Business name
		BusinessName *string `json:"businessName,omitempty"`

		// DateOfBirth The date of birth in format YYYY-MM-DD
		DateOfBirth  *string `json:"dateOfBirth,omitempty"`
		EmailAddress *string `json:"emailAddress,omitempty"`
		FirstName    *string `json:"firstName,omitempty"`

		// Id Counterparty id
		Id string `json:"id"`

		// IdDocument document used for ID verification such as passport or driver's license
		IdDocument *IdDocument `json:"idDocument,omitempty"`

		// IdentityObject Dump of data you receive from third party provider. For instance if you use plaid for bank verification, please pass us JSON value of [plaid's identity object](https://plaid.com/docs/api/products/#identity)
		IdentityObject *string `json:"identityObject,omitempty"`

		// IsEmailVerified true if email is verified
		IsEmailVerified *bool `json:"isEmailVerified,omitempty"`

		// IsKycVerified If user has been verified via KYC process
		IsKycVerified *bool `json:"isKycVerified,omitempty"`

		// IsPhoneVerified true if phone number is verified
		IsPhoneVerified *bool   `json:"isPhoneVerified,omitempty"`
		LastName        *string `json:"lastName,omitempty"`
		MiddleName      *string `json:"middleName,omitempty"`

		// Nationality Nationality of the person
		Nationality *string `json:"nationality,omitempty"`

		// PaymentMethod Payment Method
		PaymentMethod *PaymentMethod `json:"paymentMethod,omitempty"`

		// Phone The customer's phone number in [ISO E.164](https://en.wikipedia.org/wiki/E.164) format. e.g. USA: +14151231234, UK: +442012341234.
		Phone *string `json:"phone,omitempty"`

		// Source Source of personal information obtained via external third-party (non-Sardine) for verification. Discuss with Sardine before using. *MUST* be one of the following:
		Source *PostCustomerInformationJSONBodyCounterpartySource `json:"source,omitempty"`

		// Tags List of tags associated with the counterparty entity.
		Tags *[]Tags `json:"tags,omitempty"`

		// Type This is the type of counterparty entity, e.g., standard end-user (customer), a vendor, business, etc.
		Type PostCustomerInformationJSONBodyCounterpartyType `json:"type"`
	} `json:"counterparty,omitempty"`

	// CustomBool Key-value pair for boolean type custom fields to be made available in the dashboard and rule editor.
	// Example: `verifiedCustomer": true`
	CustomBool *map[string]interface{} `json:"customBool,omitempty"`

	// CustomNumber key-value pair for number type custom fields to be made available in the dashboard and rule editor.
	//
	// Example: `internalRiskScore": 57`
	CustomNumber *map[string]interface{} `json:"customNumber,omitempty"`

	// CustomString Key-value pair for string type custom fields to be made available in the dashboard and rule editor. Example: `customerSegment:premium`
	CustomString *map[string]interface{} `json:"customString,omitempty"`

	// Customer Customer details
	Customer Customer `json:"customer"`

	// Device Device details
	Device *Device `json:"device,omitempty"`

	// Flow identifies the current user flow such as onboarding, login or payment
	Flow Flow `json:"flow"`

	// PartnerId ID of the partner/business/merchant this event is tied to
	PartnerId *string `json:"partnerId,omitempty"`

	// PartnerName Name of the partner/business/merchant this event is tied to
	PartnerName *string `json:"partnerName,omitempty"`

	// ReferralCode Referral code
	ReferralCode *ReferralCode `json:"referralCode,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey string `json:"sessionKey"`

	// Transaction Transaction
	Transaction *Transaction `json:"transaction,omitempty"`

	// WorkflowName name of the workflow to be run (if using workflows instead of the `checkpoints` array)
	WorkflowName *string `json:"workflowName,omitempty"`
}

// PostCustomerInformationJSONBodyCheckpoints defines parameters for PostCustomerInformation.
type PostCustomerInformationJSONBodyCheckpoints string

// PostCustomerInformationJSONBodyCounterpartySource defines parameters for PostCustomerInformation.
type PostCustomerInformationJSONBodyCounterpartySource string

// PostCustomerInformationJSONBodyCounterpartyType defines parameters for PostCustomerInformation.
type PostCustomerInformationJSONBodyCounterpartyType string

// PostCustomersDeletionsJSONBody defines parameters for PostCustomersDeletions.
type PostCustomersDeletionsJSONBody struct {
	// Customers list of user IDs to delete data for
	Customers []string `json:"customers"`
}

// PostDocumentUploadMultipartBody defines parameters for PostDocumentUpload.
type PostDocumentUploadMultipartBody struct {
	Tag *openapi_types.File `json:"$tag,omitempty"`

	// CustomerId ID of the customer
	CustomerId *string `json:"customer_id,omitempty"`
}

// PostCustomerFeedbackJSONBody defines parameters for PostCustomerFeedback.
type PostCustomerFeedbackJSONBody struct {
	// Customer Customer details
	Customer *struct {
		// Id Id of customer
		Id *string `json:"id,omitempty"`
	} `json:"customer,omitempty"`

	// Device Device details
	Device *Device `json:"device,omitempty"`

	// Feedback Feedback
	Feedback *Feedback `json:"feedback,omitempty"`

	// Flow Identifying data for the original flow event
	Flow *struct {
		// Id The unique identifier sent in `flow.id` for the original flow event
		Id *string `json:"id,omitempty"`

		// Name The name sent in `flow.name` for the original flow event
		Name *string `json:"name,omitempty"`
	} `json:"flow,omitempty"`

	// Kind Determines the type of event the feedback is for
	Kind *PostCustomerFeedbackJSONBodyKind `json:"kind,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey string `json:"sessionKey"`

	// TrackingId merchant defined record ID
	TrackingId *string `json:"trackingId,omitempty"`

	// Transaction transaction-level detail, e.g., transaction ID, to tie feedback to an existing transaction
	Transaction *TransactionWithAuthFeedback `json:"transaction,omitempty"`
}

// PostCustomerFeedbackJSONBodyKind defines parameters for PostCustomerFeedback.
type PostCustomerFeedbackJSONBodyKind string

// PostKycTokenJSONBody defines parameters for PostKycToken.
type PostKycTokenJSONBody struct {
	// CustomerId Id for the customer. Please use the same ID you use for [v1/customers API](/guides/api-reference/customer/evaluate-customer-sessiontransaction-risk)
	CustomerId *string `json:"customerId,omitempty"`

	// Platform Platform where the token is going to be used i.e. android or ios
	Platform *string `json:"platform,omitempty"`

	// Provider Provider for the session i.e. au10tix or incode
	Provider *PostKycTokenJSONBodyProvider `json:"provider,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey string `json:"sessionKey"`
}

// PostKycTokenJSONBodyProvider defines parameters for PostKycToken.
type PostKycTokenJSONBodyProvider string

// PostKycDocumentsJSONBody defines parameters for PostKycDocuments.
type PostKycDocumentsJSONBody struct {
	// CustomerId Id for the customer. Please use the same ID you use for [v1/customers API](/guides/api-reference/customer/evaluate-customer-sessiontransaction-risk)
	CustomerId *string `json:"customerId,omitempty"`
	InputData  *struct {
		// FirstName Document holder's first name. This data is used to match against the first name captured on the document.
		FirstName *string `json:"firstName,omitempty"`

		// IssuingCountry Document's issuing country. This data is used to match against the issuing country captured on the document.
		IssuingCountry *string `json:"issuingCountry,omitempty"`

		// LastName Document holder's last name. This data is used to match against the last name captured on the document.
		LastName *string `json:"lastName,omitempty"`

		// MiddleName Document holder's middle name. This data is used to match against the middle name captured on the document.
		MiddleName *string `json:"middleName,omitempty"`
	} `json:"inputData,omitempty"`

	// RedirectURL URL were the user should be redirected to once they have completed the document verification flow.
	RedirectURL *string `json:"redirectURL,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey string `json:"sessionKey"`
}

// PostIdentityDocumentImagesJSONBody defines parameters for PostIdentityDocumentImages.
type PostIdentityDocumentImagesJSONBody struct {
	// Images An array of the image types to retrieve. Possible values - `front`, `back`, `selfie`. An empty array will default to returning all collected images
	Images *[]string `json:"images,omitempty"`

	// VerificationId ID of document verification
	VerificationId string `json:"verificationId"`
}

// GetIdentityDocumentParams defines parameters for GetIdentityDocument.
type GetIdentityDocumentParams struct {
	// Type type of request.  <br/> - "incode" if you use Incode. <br/> - "custom" if you build your own UI to capture photos. <br/> - "secure.me" if you use au10tix Web UI. <br/> - "mobilesdk" if you use au10tix native mobile SDK.
	Type string `form:"type" json:"type"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey *string `form:"sessionKey,omitempty" json:"sessionKey,omitempty"`

	// CustomerId Id for the customer. Please use the same ID you use for v1/customers API
	CustomerId *string `form:"customerId,omitempty" json:"customerId,omitempty"`
}

// PostCardsAuthorizationsJSONBody defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBody struct {
	Card *struct {
		// Balance Current card balance
		Balance *float32 `json:"balance,omitempty"`

		// BalanceCurrencyCode Currency code for the card
		BalanceCurrencyCode *string `json:"balanceCurrencyCode,omitempty"`

		// Id Card Id
		Id string `json:"id"`

		// IsVirtual If this card is virtual card
		IsVirtual *bool `json:"isVirtual,omitempty"`

		// Limit Card limit
		Limit *float32 `json:"limit,omitempty"`

		// Network Card network
		Network *PostCardsAuthorizationsJSONBodyCardNetwork `json:"network,omitempty"`
	} `json:"card,omitempty"`

	// Checkpoints Name of the checkpoints to be invoked. Defaults to `issuingrisk` if omitted.
	// You can pass custom checkpoint names after they are created. Please discuss with Sardine.
	// Example: `["issuingrisk"]`
	Checkpoints *[]string `json:"checkpoints,omitempty"`

	// CustomBool Key-value pair for boolean type custom fields to be made available in the dashboard and rule editor.
	// Example: `verifiedCustomer": true`
	CustomBool *map[string]interface{} `json:"customBool,omitempty"`

	// CustomNumber Key-value pair for number type custom fields to be made available in the dashboard and rule editor.
	// Example: `internalRiskScore": 57`
	CustomNumber *map[string]interface{} `json:"customNumber,omitempty"`

	// CustomString Key-value pair for string type custom fields to be made available in the dashboard and rule editor. Example: `customerSegment:premium`
	CustomString *map[string]interface{} `json:"customString,omitempty"`
	Customer     *struct {
		// AccountAgeInDays the age of the customer's account in days.
		AccountAgeInDays *int `json:"accountAgeInDays,omitempty"`
	} `json:"customer,omitempty"`

	// CustomerId Id of customer. Please use the same value you sent to [v1/customers API](/guides/api-reference/customer/evaluate-customer-sessiontransaction-risk)
	CustomerId string `json:"customerId"`

	// PartnerId ID of the partner/business/merchant this event is tied to
	PartnerId *string `json:"partnerId,omitempty"`

	// PartnerName Name of the partner/business/merchant this event is tied to
	PartnerName *string `json:"partnerName,omitempty"`

	// PurchaseVerification Information about the purchase verification message sent to the cardholder and channel.
	PurchaseVerification *struct {
		// Channel Details of verification channel.
		Channel *struct {
			// Email The email address the email was sent to.
			Email *string `json:"email,omitempty"`

			// PackageName The packageName the push notification was sent to.
			PackageName *string `json:"packageName,omitempty"`

			// PhoneNumber The phone number the text was sent to.
			PhoneNumber *string `json:"phoneNumber,omitempty"`

			// Type The channel the  verification message was delivered via (e.g. sms, email, push notification).
			Type *PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType `json:"type,omitempty"`
		} `json:"channel,omitempty"`

		// Device Details of device that verified the purchase.
		Device *struct {
			Ip        *string  `json:"ip,omitempty"`
			Latitude  *float32 `json:"latitude,omitempty"`
			Longitude *float32 `json:"longitude,omitempty"`

			// SessionKey The sessionKey of verification session if you use sardine device SDK.
			SessionKey *string `json:"sessionKey,omitempty"`
		} `json:"device,omitempty"`

		// SentAtMillis Time when issuer sent message.
		SentAtMillis *float32 `json:"sentAtMillis,omitempty"`

		// TransactionId  ID of transaction that triggered this verification.
		TransactionId *string `json:"transactionId,omitempty"`

		// UserResponse The responses can be - sent, delivered, approved, declined, or unknown.
		UserResponse *string `json:"userResponse,omitempty"`

		// UserResponseAtMillis Time when the user responded.
		UserResponseAtMillis *float32 `json:"userResponseAtMillis,omitempty"`
	} `json:"purchaseVerification,omitempty"`

	// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
	SessionKey  string `json:"sessionKey"`
	Transaction struct {
		// AccountBalance Current account balance
		AccountBalance *float32 `json:"accountBalance,omitempty"`

		// Address Address of payment terminal or merchant
		Address *struct {
			// City City
			City *string `json:"city,omitempty"`

			// CountryCode 2 letter Country code for the customer in [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) code e.g. US
			CountryCode *string `json:"countryCode,omitempty"`

			// PostalCode Postal code or zipcode
			PostalCode *string `json:"postalCode,omitempty"`

			// RegionCode State code (e.g. CA), province code (e.g. ON), other other region code
			RegionCode *string `json:"regionCode,omitempty"`

			// Street1 Street
			Street1 *string `json:"street1,omitempty"`

			// Street2 Street
			Street2 *string `json:"street2,omitempty"`
		} `json:"address,omitempty"`

		// Amount Amount of transaction. Major unit of currency (e.g. 9.99 dollars for USD)
		Amount float32 `json:"amount"`

		// CreatedAtMillis Unix timestamp in milliseconds for the transaction authorization time
		CreatedAtMillis *int64 `json:"createdAtMillis,omitempty"`

		// CurrencyCode 3-digit [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code
		CurrencyCode string `json:"currencyCode"`

		// EntryInfo How card information was entered
		EntryInfo *struct {
			// Card If card was present
			Card PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard `json:"card"`

			// CardHolder If card holder was present
			CardHolder PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder `json:"cardHolder"`

			// Pan How pan was entered
			Pan PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan `json:"pan"`

			// PinEntered If pin was entered
			PinEntered *bool `json:"pinEntered,omitempty"`
		} `json:"entryInfo,omitempty"`

		// ForeignTransaction If the transaction takes place in different country than the cardholder's country
		ForeignTransaction *bool `json:"foreignTransaction,omitempty"`

		// FraudScore Fraud score you get from network and your partner
		FraudScore *struct {
			// NetworkScore Score from network. Range 0-1000 (Visa VAA score should be multiplied by 10 to match the range).
			NetworkScore *int `json:"networkScore,omitempty"`

			// PartnerScore Score from your partner
			PartnerScore *float32 `json:"partnerScore,omitempty"`

			// Reason String explaining the score
			Reason *string `json:"reason,omitempty"`
		} `json:"fraudScore,omitempty"`

		// Id ID of the transaction
		Id string `json:"id"`

		// Merchant Information about merchant
		Merchant *struct {
			// Id The "Merchant Identifier" used by the card network to identify the merchant
			Id *string `json:"id,omitempty"`

			// Mcc 4-digit merchant category code
			Mcc string `json:"mcc"`

			// Name Name of merchant
			Name *string `json:"name,omitempty"`
		} `json:"merchant,omitempty"`

		// Note Memo associated with the transaction.
		Note *string `json:"note,omitempty"`

		// Recurring If transaction is recurring payment
		Recurring *bool `json:"recurring,omitempty"`

		// Status status of card authorization
		Status *PostCardsAuthorizationsJSONBodyTransactionStatus `json:"status,omitempty"`

		// Terminal Payment terminal
		Terminal *struct {
			// Id ID of payment terminal
			Id *string `json:"id,omitempty"`

			// OnPremise True if the sale was made at the place of business (vs. mobile)
			OnPremise *bool `json:"onPremise,omitempty"`

			// Operator The person that is designed to swipe the card
			Operator PostCardsAuthorizationsJSONBodyTransactionTerminalOperator `json:"operator"`

			// PinCapability Status of whether the POS is able to accept PINs
			PinCapability *bool `json:"pinCapability,omitempty"`

			// Type Type of payment terminal
			Type PostCardsAuthorizationsJSONBodyTransactionTerminalType `json:"type"`
		} `json:"terminal,omitempty"`

		// Type Type of transaction
		Type *PostCardsAuthorizationsJSONBodyTransactionType `json:"type,omitempty"`

		// Validation validation information
		Validation *struct {
			// AvsData Data related to avs
			AvsData *struct {
				Address *string `json:"address,omitempty"`
				Zip     *string `json:"zip,omitempty"`
			} `json:"avsData,omitempty"`

			// AvsStreet Result of AVS check for street address
			AvsStreet PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet `json:"avsStreet"`

			// AvsZip Result of AVS check for zip code
			AvsZip PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip `json:"avsZip"`

			// Cvv Result of cvv match check
			Cvv PostCardsAuthorizationsJSONBodyTransactionValidationCvv `json:"cvv"`
		} `json:"validation,omitempty"`
	} `json:"transaction"`
}

// PostCardsAuthorizationsJSONBodyCardNetwork defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyCardNetwork string

// PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyPurchaseVerificationChannelType string

// PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionEntryInfoCard string

// PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionEntryInfoCardHolder string

// PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionEntryInfoPan string

// PostCardsAuthorizationsJSONBodyTransactionStatus defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionStatus string

// PostCardsAuthorizationsJSONBodyTransactionTerminalOperator defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionTerminalOperator string

// PostCardsAuthorizationsJSONBodyTransactionTerminalType defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionTerminalType string

// PostCardsAuthorizationsJSONBodyTransactionType defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionType string

// PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionValidationAvsStreet string

// PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionValidationAvsZip string

// PostCardsAuthorizationsJSONBodyTransactionValidationCvv defines parameters for PostCardsAuthorizations.
type PostCardsAuthorizationsJSONBodyTransactionValidationCvv string

// DeleteMonitoringDataParams defines parameters for DeleteMonitoringData.
type DeleteMonitoringDataParams struct {
	// CustomerId The ID of the customer whose monitoring data is to be deleted
	CustomerId *string `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// BizTrackingId The tracking ID of the biz whose monitoring data is to be deleted
	BizTrackingId *string `form:"biz_tracking_id,omitempty" json:"biz_tracking_id,omitempty"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	// Checkpoint Sardine identifier for the checkpoint
	Checkpoint string `form:"checkpoint" json:"checkpoint"`
}

// GetRuleDetailsParams defines parameters for GetRuleDetails.
type GetRuleDetailsParams struct {
	// RuleId Sardine identifier for the rule
	RuleId int `form:"ruleId" json:"ruleId"`
}

// GetSanctionAlertsJSONBody defines parameters for GetSanctionAlerts.
type GetSanctionAlertsJSONBody struct {
	// Cursor link to the next page. Initial you can leave the cursor empty following that you need to add the cursor to your request to get next set of results.
	Cursor *string `json:"cursor,omitempty"`

	// End unix timestamp in milliseconds
	End float32 `json:"end"`

	// Start start time for checking udpated data. unix timestamp in milliseconds
	Start float32 `json:"start"`
}

// NewSubaccountJSONBody defines parameters for NewSubaccount.
type NewSubaccountJSONBody struct {
	// Name name of subaccount
	Name string `json:"name"`
}

// NewSubaccount1JSONBody defines parameters for NewSubaccount1.
type NewSubaccount1JSONBody struct {
	// AccountId ID of subaccount
	AccountId string `json:"accountId"`
}

// V2DevicesJSONBody defines parameters for V2Devices.
type V2DevicesJSONBody struct {
	// Checkpoints Name of the checkpoints to be invoked. Allowed values are `device` and `login`. Defaults to `device` if omitted. Please discuss with Sardine.
	Checkpoints *[]V2DevicesJSONBodyCheckpoints `json:"checkpoints,omitempty"`

	// Device Device details
	Device  *Device `json:"device,omitempty"`
	Payload *struct {
		// BasicIntegrity GoogleSafetynet basic integrity, if you use [Google SafetyNet](https://developer.android.com/training/safetynet/attestation) (Android only)
		BasicIntegrity *bool `json:"basicIntegrity,omitempty"`

		// CtsProfileMatch GoogleSafetyNet cts profile match, if you use [Google SafetyNet](https://developer.android.com/training/safetynet/attestation) (Android only)
		CtsProfileMatch *bool `json:"ctsProfileMatch,omitempty"`

		// UserIdHash Hash of UserId.
		UserIdHash *string `json:"userIdHash,omitempty"`
	} `json:"payload,omitempty"`

	// ReferralCode Referral code
	ReferralCode *ReferralCode `json:"referralCode,omitempty"`

	// SessionKey Identifier for the session passed from the client
	SessionKey string `json:"sessionKey"`
}

// V2DevicesJSONBodyCheckpoints defines parameters for V2Devices.
type V2DevicesJSONBodyCheckpoints string

// PostPlaidProcessorTokenJSONRequestBody defines body for PostPlaidProcessorToken for application/json ContentType.
type PostPlaidProcessorTokenJSONRequestBody PostPlaidProcessorTokenJSONBody

// PlaidDataSyncJSONRequestBody defines body for PlaidDataSync for application/json ContentType.
type PlaidDataSyncJSONRequestBody PlaidDataSyncJSONBody

// PostAllowListCreateJSONRequestBody defines body for PostAllowListCreate for application/json ContentType.
type PostAllowListCreateJSONRequestBody PostAllowListCreateJSONBody

// PostAllowlistExpireJSONRequestBody defines body for PostAllowlistExpire for application/json ContentType.
type PostAllowlistExpireJSONRequestBody PostAllowlistExpireJSONBody

// PostAllowlistFindJSONRequestBody defines body for PostAllowlistFind for application/json ContentType.
type PostAllowlistFindJSONRequestBody PostAllowlistFindJSONBody

// PostBankTransactionsJSONRequestBody defines body for PostBankTransactions for application/json ContentType.
type PostBankTransactionsJSONRequestBody PostBankTransactionsJSONBody

// PostClientBlocklistsJSONRequestBody defines body for PostClientBlocklists for application/json ContentType.
type PostClientBlocklistsJSONRequestBody PostClientBlocklistsJSONBody

// PostBlockListExpireJSONRequestBody defines body for PostBlockListExpire for application/json ContentType.
type PostBlockListExpireJSONRequestBody PostBlockListExpireJSONBody

// PostSpecificBlockListJSONRequestBody defines body for PostSpecificBlockList for application/json ContentType.
type PostSpecificBlockListJSONRequestBody PostSpecificBlockListJSONBody

// UpdateBizJSONRequestBody defines body for UpdateBiz for application/json ContentType.
type UpdateBizJSONRequestBody UpdateBizJSONBody

// AddUpdateBizJSONRequestBody defines body for AddUpdateBiz for application/json ContentType.
type AddUpdateBizJSONRequestBody AddUpdateBizJSONBody

// PostV1BusinessesScreeningPmsJSONRequestBody defines body for PostV1BusinessesScreeningPms for application/json ContentType.
type PostV1BusinessesScreeningPmsJSONRequestBody PostV1BusinessesScreeningPmsJSONBody

// NewCaseJSONRequestBody defines body for NewCase for application/json ContentType.
type NewCaseJSONRequestBody NewCaseJSONBody

// UpdateCaseJSONRequestBody defines body for UpdateCase for application/json ContentType.
type UpdateCaseJSONRequestBody UpdateCaseJSONBody

// PostCustomListJSONRequestBody defines body for PostCustomList for application/json ContentType.
type PostCustomListJSONRequestBody PostCustomListJSONBody

// PostCustomListDeleteJSONRequestBody defines body for PostCustomListDelete for application/json ContentType.
type PostCustomListDeleteJSONRequestBody PostCustomListDeleteJSONBody

// PostNewListItemsJSONRequestBody defines body for PostNewListItems for application/json ContentType.
type PostNewListItemsJSONRequestBody PostNewListItemsJSONBody

// PostItemsDeleteJSONRequestBody defines body for PostItemsDelete for application/json ContentType.
type PostItemsDeleteJSONRequestBody PostItemsDeleteJSONBody

// PostCustomerInformationJSONRequestBody defines body for PostCustomerInformation for application/json ContentType.
type PostCustomerInformationJSONRequestBody PostCustomerInformationJSONBody

// PostCustomersDeletionsJSONRequestBody defines body for PostCustomersDeletions for application/json ContentType.
type PostCustomersDeletionsJSONRequestBody PostCustomersDeletionsJSONBody

// PostDocumentUploadMultipartRequestBody defines body for PostDocumentUpload for multipart/form-data ContentType.
type PostDocumentUploadMultipartRequestBody PostDocumentUploadMultipartBody

// PostCustomerFeedbackJSONRequestBody defines body for PostCustomerFeedback for application/json ContentType.
type PostCustomerFeedbackJSONRequestBody PostCustomerFeedbackJSONBody

// PostKycTokenJSONRequestBody defines body for PostKycToken for application/json ContentType.
type PostKycTokenJSONRequestBody PostKycTokenJSONBody

// PostKycDocumentsJSONRequestBody defines body for PostKycDocuments for application/json ContentType.
type PostKycDocumentsJSONRequestBody PostKycDocumentsJSONBody

// PostIdentityDocumentImagesJSONRequestBody defines body for PostIdentityDocumentImages for application/json ContentType.
type PostIdentityDocumentImagesJSONRequestBody PostIdentityDocumentImagesJSONBody

// PostCardsAuthorizationsJSONRequestBody defines body for PostCardsAuthorizations for application/json ContentType.
type PostCardsAuthorizationsJSONRequestBody PostCardsAuthorizationsJSONBody

// GetSanctionAlertsJSONRequestBody defines body for GetSanctionAlerts for application/json ContentType.
type GetSanctionAlertsJSONRequestBody GetSanctionAlertsJSONBody

// NewSubaccountJSONRequestBody defines body for NewSubaccount for application/json ContentType.
type NewSubaccountJSONRequestBody NewSubaccountJSONBody

// NewSubaccount1JSONRequestBody defines body for NewSubaccount1 for application/json ContentType.
type NewSubaccount1JSONRequestBody NewSubaccount1JSONBody

// V2DevicesJSONRequestBody defines body for V2Devices for application/json ContentType.
type V2DevicesJSONRequestBody V2DevicesJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostPlaidProcessorTokenWithBody request with any body
	PostPlaidProcessorTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPlaidProcessorToken(ctx context.Context, body PostPlaidProcessorTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlaidDataSyncWithBody request with any body
	PlaidDataSyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlaidDataSync(ctx context.Context, body PlaidDataSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllowlistClient request
	GetAllowlistClient(ctx context.Context, params *GetAllowlistClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAllowListCreateWithBody request with any body
	PostAllowListCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAllowListCreate(ctx context.Context, body PostAllowListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAllowlistExpireWithBody request with any body
	PostAllowlistExpireWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAllowlistExpire(ctx context.Context, body PostAllowlistExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAllowlistFindWithBody request with any body
	PostAllowlistFindWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAllowlistFind(ctx context.Context, body PostAllowlistFindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBankTransactionsWithBody request with any body
	PostBankTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBankTransactions(ctx context.Context, body PostBankTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientBlocklists request
	GetClientBlocklists(ctx context.Context, params *GetClientBlocklistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClientBlocklistsWithBody request with any body
	PostClientBlocklistsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClientBlocklists(ctx context.Context, body PostClientBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBlockListExpireWithBody request with any body
	PostBlockListExpireWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBlockListExpire(ctx context.Context, body PostBlockListExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSpecificBlockListWithBody request with any body
	PostSpecificBlockListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSpecificBlockList(ctx context.Context, body PostSpecificBlockListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Getbix request
	Getbix(ctx context.Context, params *GetbixParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBizWithBody request with any body
	UpdateBizWithBody(ctx context.Context, params *UpdateBizParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBiz(ctx context.Context, params *UpdateBizParams, body UpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUpdateBizWithBody request with any body
	AddUpdateBizWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUpdateBiz(ctx context.Context, body AddUpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV1BusinessesScreeningPmsWithBody request with any body
	PostV1BusinessesScreeningPmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV1BusinessesScreeningPms(ctx context.Context, body PostV1BusinessesScreeningPmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCase request
	GetCase(ctx context.Context, params *GetCaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewCaseWithBody request with any body
	NewCaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewCase(ctx context.Context, body NewCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCaseWithBody request with any body
	UpdateCaseWithBody(ctx context.Context, params *UpdateCaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCase(ctx context.Context, params *UpdateCaseParams, body UpdateCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomListWithBody request with any body
	PostCustomListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomList(ctx context.Context, body PostCustomListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomListDeleteWithBody request with any body
	PostCustomListDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomListDelete(ctx context.Context, body PostCustomListDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNewListItemsWithBody request with any body
	PostNewListItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNewListItems(ctx context.Context, body PostNewListItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostItemsDeleteWithBody request with any body
	PostItemsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostItemsDelete(ctx context.Context, body PostItemsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomListRetrieve request
	GetCustomListRetrieve(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerInformationWithBody request with any body
	PostCustomerInformationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerInformation(ctx context.Context, body PostCustomerInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersDeletionsWithBody request with any body
	PostCustomersDeletionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomersDeletions(ctx context.Context, body PostCustomersDeletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDocumentUploadWithBody request with any body
	PostDocumentUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerFeedbackWithBody request with any body
	PostCustomerFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerFeedback(ctx context.Context, body PostCustomerFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostKycTokenWithBody request with any body
	PostKycTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostKycToken(ctx context.Context, body PostKycTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostKycDocumentsWithBody request with any body
	PostKycDocumentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostKycDocuments(ctx context.Context, body PostKycDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostIdentityDocumentImagesWithBody request with any body
	PostIdentityDocumentImagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostIdentityDocumentImages(ctx context.Context, body PostIdentityDocumentImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityDocument request
	GetIdentityDocument(ctx context.Context, id string, params *GetIdentityDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCardsAuthorizationsWithBody request with any body
	PostCardsAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCardsAuthorizations(ctx context.Context, body PostCardsAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMonitoringData request
	DeleteMonitoringData(ctx context.Context, params *DeleteMonitoringDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleDetails request
	GetRuleDetails(ctx context.Context, params *GetRuleDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSanctionAlertsWithBody request with any body
	GetSanctionAlertsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSanctionAlerts(ctx context.Context, body GetSanctionAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewSubaccountWithBody request with any body
	NewSubaccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewSubaccount(ctx context.Context, body NewSubaccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewSubaccount1WithBody request with any body
	NewSubaccount1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewSubaccount1(ctx context.Context, body NewSubaccount1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V2DevicesWithBody request with any body
	V2DevicesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V2Devices(ctx context.Context, body V2DevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostPlaidProcessorTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlaidProcessorTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlaidProcessorToken(ctx context.Context, body PostPlaidProcessorTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlaidProcessorTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaidDataSyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaidDataSyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaidDataSync(ctx context.Context, body PlaidDataSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaidDataSyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllowlistClient(ctx context.Context, params *GetAllowlistClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllowlistClientRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowListCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowListCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowListCreate(ctx context.Context, body PostAllowListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowListCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowlistExpireWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowlistExpireRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowlistExpire(ctx context.Context, body PostAllowlistExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowlistExpireRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowlistFindWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowlistFindRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAllowlistFind(ctx context.Context, body PostAllowlistFindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAllowlistFindRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBankTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBankTransactionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBankTransactions(ctx context.Context, body PostBankTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBankTransactionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientBlocklists(ctx context.Context, params *GetClientBlocklistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientBlocklistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClientBlocklistsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientBlocklistsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClientBlocklists(ctx context.Context, body PostClientBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClientBlocklistsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlockListExpireWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlockListExpireRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBlockListExpire(ctx context.Context, body PostBlockListExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBlockListExpireRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSpecificBlockListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSpecificBlockListRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSpecificBlockList(ctx context.Context, body PostSpecificBlockListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSpecificBlockListRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Getbix(ctx context.Context, params *GetbixParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetbixRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBizWithBody(ctx context.Context, params *UpdateBizParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBizRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBiz(ctx context.Context, params *UpdateBizParams, body UpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBizRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUpdateBizWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUpdateBizRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUpdateBiz(ctx context.Context, body AddUpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUpdateBizRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1BusinessesScreeningPmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1BusinessesScreeningPmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV1BusinessesScreeningPms(ctx context.Context, body PostV1BusinessesScreeningPmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV1BusinessesScreeningPmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCase(ctx context.Context, params *GetCaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewCaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewCase(ctx context.Context, body NewCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCaseWithBody(ctx context.Context, params *UpdateCaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCase(ctx context.Context, params *UpdateCaseParams, body UpdateCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomListRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomList(ctx context.Context, body PostCustomListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomListRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomListDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomListDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomListDelete(ctx context.Context, body PostCustomListDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomListDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNewListItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNewListItemsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNewListItems(ctx context.Context, body PostNewListItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNewListItemsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostItemsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostItemsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostItemsDelete(ctx context.Context, body PostItemsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostItemsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomListRetrieve(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomListRetrieveRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerInformationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerInformationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerInformation(ctx context.Context, body PostCustomerInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerInformationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersDeletionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersDeletionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersDeletions(ctx context.Context, body PostCustomersDeletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersDeletionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDocumentUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDocumentUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerFeedbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerFeedback(ctx context.Context, body PostCustomerFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerFeedbackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKycTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKycTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKycToken(ctx context.Context, body PostKycTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKycTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKycDocumentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKycDocumentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKycDocuments(ctx context.Context, body PostKycDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKycDocumentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdentityDocumentImagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIdentityDocumentImagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdentityDocumentImages(ctx context.Context, body PostIdentityDocumentImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIdentityDocumentImagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityDocument(ctx context.Context, id string, params *GetIdentityDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityDocumentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCardsAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCardsAuthorizationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCardsAuthorizations(ctx context.Context, body PostCardsAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCardsAuthorizationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMonitoringData(ctx context.Context, params *DeleteMonitoringDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMonitoringDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleDetails(ctx context.Context, params *GetRuleDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSanctionAlertsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSanctionAlertsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSanctionAlerts(ctx context.Context, body GetSanctionAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSanctionAlertsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSubaccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSubaccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSubaccount(ctx context.Context, body NewSubaccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSubaccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSubaccount1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSubaccount1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewSubaccount1(ctx context.Context, body NewSubaccount1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewSubaccount1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V2DevicesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV2DevicesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V2Devices(ctx context.Context, body V2DevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV2DevicesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostPlaidProcessorTokenRequest calls the generic PostPlaidProcessorToken builder with application/json body
func NewPostPlaidProcessorTokenRequest(server string, body PostPlaidProcessorTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPlaidProcessorTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPlaidProcessorTokenRequestWithBody generates requests for PostPlaidProcessorToken with any type of body
func NewPostPlaidProcessorTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/open-banking/processor-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPlaidDataSyncRequest calls the generic PlaidDataSync builder with application/json body
func NewPlaidDataSyncRequest(server string, body PlaidDataSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlaidDataSyncRequestWithBody(server, "application/json", bodyReader)
}

// NewPlaidDataSyncRequestWithBody generates requests for PlaidDataSync with any type of body
func NewPlaidDataSyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/open-banking/trigger-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllowlistClientRequest generates requests for GetAllowlistClient
func NewGetAllowlistClientRequest(server string, params *GetAllowlistClientParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/allowlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextCursor", runtime.ParamLocationQuery, *params.NextCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAllowListCreateRequest calls the generic PostAllowListCreate builder with application/json body
func NewPostAllowListCreateRequest(server string, body PostAllowListCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAllowListCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAllowListCreateRequestWithBody generates requests for PostAllowListCreate with any type of body
func NewPostAllowListCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/allowlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAllowlistExpireRequest calls the generic PostAllowlistExpire builder with application/json body
func NewPostAllowlistExpireRequest(server string, body PostAllowlistExpireJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAllowlistExpireRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAllowlistExpireRequestWithBody generates requests for PostAllowlistExpire with any type of body
func NewPostAllowlistExpireRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/allowlists/expire")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAllowlistFindRequest calls the generic PostAllowlistFind builder with application/json body
func NewPostAllowlistFindRequest(server string, body PostAllowlistFindJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAllowlistFindRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAllowlistFindRequestWithBody generates requests for PostAllowlistFind with any type of body
func NewPostAllowlistFindRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/allowlists/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBankTransactionsRequest calls the generic PostBankTransactions builder with application/json body
func NewPostBankTransactionsRequest(server string, body PostBankTransactionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBankTransactionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBankTransactionsRequestWithBody generates requests for PostBankTransactions with any type of body
func NewPostBankTransactionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/banks/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientBlocklistsRequest generates requests for GetClientBlocklists
func NewGetClientBlocklistsRequest(server string, params *GetClientBlocklistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextCursor", runtime.ParamLocationQuery, *params.NextCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClientBlocklistsRequest calls the generic PostClientBlocklists builder with application/json body
func NewPostClientBlocklistsRequest(server string, body PostClientBlocklistsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClientBlocklistsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostClientBlocklistsRequestWithBody generates requests for PostClientBlocklists with any type of body
func NewPostClientBlocklistsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBlockListExpireRequest calls the generic PostBlockListExpire builder with application/json body
func NewPostBlockListExpireRequest(server string, body PostBlockListExpireJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBlockListExpireRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBlockListExpireRequestWithBody generates requests for PostBlockListExpire with any type of body
func NewPostBlockListExpireRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/blocklists/expire")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSpecificBlockListRequest calls the generic PostSpecificBlockList builder with application/json body
func NewPostSpecificBlockListRequest(server string, body PostSpecificBlockListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSpecificBlockListRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSpecificBlockListRequestWithBody generates requests for PostSpecificBlockList with any type of body
func NewPostSpecificBlockListRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/blocklists/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetbixRequest generates requests for Getbix
func NewGetbixRequest(server string, params *GetbixParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/businesses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBizRequest calls the generic UpdateBiz builder with application/json body
func NewUpdateBizRequest(server string, params *UpdateBizParams, body UpdateBizJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBizRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateBizRequestWithBody generates requests for UpdateBiz with any type of body
func NewUpdateBizRequestWithBody(server string, params *UpdateBizParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/businesses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUpdateBizRequest calls the generic AddUpdateBiz builder with application/json body
func NewAddUpdateBizRequest(server string, body AddUpdateBizJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUpdateBizRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUpdateBizRequestWithBody generates requests for AddUpdateBiz with any type of body
func NewAddUpdateBizRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/businesses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV1BusinessesScreeningPmsRequest calls the generic PostV1BusinessesScreeningPms builder with application/json body
func NewPostV1BusinessesScreeningPmsRequest(server string, body PostV1BusinessesScreeningPmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV1BusinessesScreeningPmsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostV1BusinessesScreeningPmsRequestWithBody generates requests for PostV1BusinessesScreeningPms with any type of body
func NewPostV1BusinessesScreeningPmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/businesses/screening/pms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCaseRequest generates requests for GetCase
func NewGetCaseRequest(server string, params *GetCaseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/cases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewCaseRequest calls the generic NewCase builder with application/json body
func NewNewCaseRequest(server string, body NewCaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewCaseRequestWithBody(server, "application/json", bodyReader)
}

// NewNewCaseRequestWithBody generates requests for NewCase with any type of body
func NewNewCaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/cases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCaseRequest calls the generic UpdateCase builder with application/json body
func NewUpdateCaseRequest(server string, params *UpdateCaseParams, body UpdateCaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCaseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateCaseRequestWithBody generates requests for UpdateCase with any type of body
func NewUpdateCaseRequestWithBody(server string, params *UpdateCaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/cases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomListRequest calls the generic PostCustomList builder with application/json body
func NewPostCustomListRequest(server string, body PostCustomListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomListRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomListRequestWithBody generates requests for PostCustomList with any type of body
func NewPostCustomListRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/client-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomListDeleteRequest calls the generic PostCustomListDelete builder with application/json body
func NewPostCustomListDeleteRequest(server string, body PostCustomListDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomListDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomListDeleteRequestWithBody generates requests for PostCustomListDelete with any type of body
func NewPostCustomListDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/client-lists/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNewListItemsRequest calls the generic PostNewListItems builder with application/json body
func NewPostNewListItemsRequest(server string, body PostNewListItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNewListItemsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNewListItemsRequestWithBody generates requests for PostNewListItems with any type of body
func NewPostNewListItemsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/client-lists/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostItemsDeleteRequest calls the generic PostItemsDelete builder with application/json body
func NewPostItemsDeleteRequest(server string, body PostItemsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostItemsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostItemsDeleteRequestWithBody generates requests for PostItemsDelete with any type of body
func NewPostItemsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/client-lists/items/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomListRetrieveRequest generates requests for GetCustomListRetrieve
func NewGetCustomListRetrieveRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/client-lists/retrieve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomerInformationRequest calls the generic PostCustomerInformation builder with application/json body
func NewPostCustomerInformationRequest(server string, body PostCustomerInformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerInformationRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomerInformationRequestWithBody generates requests for PostCustomerInformation with any type of body
func NewPostCustomerInformationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomersDeletionsRequest calls the generic PostCustomersDeletions builder with application/json body
func NewPostCustomersDeletionsRequest(server string, body PostCustomersDeletionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersDeletionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomersDeletionsRequestWithBody generates requests for PostCustomersDeletions with any type of body
func NewPostCustomersDeletionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/customers/deletions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDocumentUploadRequestWithBody generates requests for PostDocumentUpload with any type of body
func NewPostDocumentUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/documents/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomerFeedbackRequest calls the generic PostCustomerFeedback builder with application/json body
func NewPostCustomerFeedbackRequest(server string, body PostCustomerFeedbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerFeedbackRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomerFeedbackRequestWithBody generates requests for PostCustomerFeedback with any type of body
func NewPostCustomerFeedbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/feedbacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostKycTokenRequest calls the generic PostKycToken builder with application/json body
func NewPostKycTokenRequest(server string, body PostKycTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostKycTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostKycTokenRequestWithBody generates requests for PostKycToken with any type of body
func NewPostKycTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-documents/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostKycDocumentsRequest calls the generic PostKycDocuments builder with application/json body
func NewPostKycDocumentsRequest(server string, body PostKycDocumentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostKycDocumentsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostKycDocumentsRequestWithBody generates requests for PostKycDocuments with any type of body
func NewPostKycDocumentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-documents/urls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostIdentityDocumentImagesRequest calls the generic PostIdentityDocumentImages builder with application/json body
func NewPostIdentityDocumentImagesRequest(server string, body PostIdentityDocumentImagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostIdentityDocumentImagesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostIdentityDocumentImagesRequestWithBody generates requests for PostIdentityDocumentImages with any type of body
func NewPostIdentityDocumentImagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-documents/verifications/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIdentityDocumentRequest generates requests for GetIdentityDocument
func NewGetIdentityDocumentRequest(server string, id string, params *GetIdentityDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/identity-documents/verifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SessionKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sessionKey", runtime.ParamLocationQuery, *params.SessionKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customerId", runtime.ParamLocationQuery, *params.CustomerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCardsAuthorizationsRequest calls the generic PostCardsAuthorizations builder with application/json body
func NewPostCardsAuthorizationsRequest(server string, body PostCardsAuthorizationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCardsAuthorizationsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCardsAuthorizationsRequestWithBody generates requests for PostCardsAuthorizations with any type of body
func NewPostCardsAuthorizationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/issuing/risks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMonitoringDataRequest generates requests for DeleteMonitoringData
func NewDeleteMonitoringDataRequest(server string, params *DeleteMonitoringDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_id", runtime.ParamLocationQuery, *params.CustomerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BizTrackingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "biz_tracking_id", runtime.ParamLocationQuery, *params.BizTrackingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkpoint", runtime.ParamLocationQuery, params.Checkpoint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleDetailsRequest generates requests for GetRuleDetails
func NewGetRuleDetailsRequest(server string, params *GetRuleDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/details")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, params.RuleId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSanctionAlertsRequest calls the generic GetSanctionAlerts builder with application/json body
func NewGetSanctionAlertsRequest(server string, body GetSanctionAlertsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSanctionAlertsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSanctionAlertsRequestWithBody generates requests for GetSanctionAlerts with any type of body
func NewGetSanctionAlertsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/screening/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNewSubaccountRequest calls the generic NewSubaccount builder with application/json body
func NewNewSubaccountRequest(server string, body NewSubaccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewSubaccountRequestWithBody(server, "application/json", bodyReader)
}

// NewNewSubaccountRequestWithBody generates requests for NewSubaccount with any type of body
func NewNewSubaccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/subaccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNewSubaccount1Request calls the generic NewSubaccount1 builder with application/json body
func NewNewSubaccount1Request(server string, body NewSubaccount1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewSubaccount1RequestWithBody(server, "application/json", bodyReader)
}

// NewNewSubaccount1RequestWithBody generates requests for NewSubaccount1 with any type of body
func NewNewSubaccount1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/subaccounts/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV2DevicesRequest calls the generic V2Devices builder with application/json body
func NewV2DevicesRequest(server string, body V2DevicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV2DevicesRequestWithBody(server, "application/json", bodyReader)
}

// NewV2DevicesRequestWithBody generates requests for V2Devices with any type of body
func NewV2DevicesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostPlaidProcessorTokenWithBodyWithResponse request with any body
	PostPlaidProcessorTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlaidProcessorTokenResponse, error)

	PostPlaidProcessorTokenWithResponse(ctx context.Context, body PostPlaidProcessorTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlaidProcessorTokenResponse, error)

	// PlaidDataSyncWithBodyWithResponse request with any body
	PlaidDataSyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlaidDataSyncResponse, error)

	PlaidDataSyncWithResponse(ctx context.Context, body PlaidDataSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PlaidDataSyncResponse, error)

	// GetAllowlistClientWithResponse request
	GetAllowlistClientWithResponse(ctx context.Context, params *GetAllowlistClientParams, reqEditors ...RequestEditorFn) (*GetAllowlistClientResponse, error)

	// PostAllowListCreateWithBodyWithResponse request with any body
	PostAllowListCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowListCreateResponse, error)

	PostAllowListCreateWithResponse(ctx context.Context, body PostAllowListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowListCreateResponse, error)

	// PostAllowlistExpireWithBodyWithResponse request with any body
	PostAllowlistExpireWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowlistExpireResponse, error)

	PostAllowlistExpireWithResponse(ctx context.Context, body PostAllowlistExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowlistExpireResponse, error)

	// PostAllowlistFindWithBodyWithResponse request with any body
	PostAllowlistFindWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowlistFindResponse, error)

	PostAllowlistFindWithResponse(ctx context.Context, body PostAllowlistFindJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowlistFindResponse, error)

	// PostBankTransactionsWithBodyWithResponse request with any body
	PostBankTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBankTransactionsResponse, error)

	PostBankTransactionsWithResponse(ctx context.Context, body PostBankTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBankTransactionsResponse, error)

	// GetClientBlocklistsWithResponse request
	GetClientBlocklistsWithResponse(ctx context.Context, params *GetClientBlocklistsParams, reqEditors ...RequestEditorFn) (*GetClientBlocklistsResponse, error)

	// PostClientBlocklistsWithBodyWithResponse request with any body
	PostClientBlocklistsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientBlocklistsResponse, error)

	PostClientBlocklistsWithResponse(ctx context.Context, body PostClientBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientBlocklistsResponse, error)

	// PostBlockListExpireWithBodyWithResponse request with any body
	PostBlockListExpireWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlockListExpireResponse, error)

	PostBlockListExpireWithResponse(ctx context.Context, body PostBlockListExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlockListExpireResponse, error)

	// PostSpecificBlockListWithBodyWithResponse request with any body
	PostSpecificBlockListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSpecificBlockListResponse, error)

	PostSpecificBlockListWithResponse(ctx context.Context, body PostSpecificBlockListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSpecificBlockListResponse, error)

	// GetbixWithResponse request
	GetbixWithResponse(ctx context.Context, params *GetbixParams, reqEditors ...RequestEditorFn) (*GetbixResponse, error)

	// UpdateBizWithBodyWithResponse request with any body
	UpdateBizWithBodyWithResponse(ctx context.Context, params *UpdateBizParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBizResponse, error)

	UpdateBizWithResponse(ctx context.Context, params *UpdateBizParams, body UpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBizResponse, error)

	// AddUpdateBizWithBodyWithResponse request with any body
	AddUpdateBizWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUpdateBizResponse, error)

	AddUpdateBizWithResponse(ctx context.Context, body AddUpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUpdateBizResponse, error)

	// PostV1BusinessesScreeningPmsWithBodyWithResponse request with any body
	PostV1BusinessesScreeningPmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1BusinessesScreeningPmsResponse, error)

	PostV1BusinessesScreeningPmsWithResponse(ctx context.Context, body PostV1BusinessesScreeningPmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1BusinessesScreeningPmsResponse, error)

	// GetCaseWithResponse request
	GetCaseWithResponse(ctx context.Context, params *GetCaseParams, reqEditors ...RequestEditorFn) (*GetCaseResponse, error)

	// NewCaseWithBodyWithResponse request with any body
	NewCaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCaseResponse, error)

	NewCaseWithResponse(ctx context.Context, body NewCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCaseResponse, error)

	// UpdateCaseWithBodyWithResponse request with any body
	UpdateCaseWithBodyWithResponse(ctx context.Context, params *UpdateCaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaseResponse, error)

	UpdateCaseWithResponse(ctx context.Context, params *UpdateCaseParams, body UpdateCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaseResponse, error)

	// PostCustomListWithBodyWithResponse request with any body
	PostCustomListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomListResponse, error)

	PostCustomListWithResponse(ctx context.Context, body PostCustomListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomListResponse, error)

	// PostCustomListDeleteWithBodyWithResponse request with any body
	PostCustomListDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomListDeleteResponse, error)

	PostCustomListDeleteWithResponse(ctx context.Context, body PostCustomListDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomListDeleteResponse, error)

	// PostNewListItemsWithBodyWithResponse request with any body
	PostNewListItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNewListItemsResponse, error)

	PostNewListItemsWithResponse(ctx context.Context, body PostNewListItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNewListItemsResponse, error)

	// PostItemsDeleteWithBodyWithResponse request with any body
	PostItemsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostItemsDeleteResponse, error)

	PostItemsDeleteWithResponse(ctx context.Context, body PostItemsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostItemsDeleteResponse, error)

	// GetCustomListRetrieveWithResponse request
	GetCustomListRetrieveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCustomListRetrieveResponse, error)

	// PostCustomerInformationWithBodyWithResponse request with any body
	PostCustomerInformationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerInformationResponse, error)

	PostCustomerInformationWithResponse(ctx context.Context, body PostCustomerInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerInformationResponse, error)

	// PostCustomersDeletionsWithBodyWithResponse request with any body
	PostCustomersDeletionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersDeletionsResponse, error)

	PostCustomersDeletionsWithResponse(ctx context.Context, body PostCustomersDeletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersDeletionsResponse, error)

	// PostDocumentUploadWithBodyWithResponse request with any body
	PostDocumentUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDocumentUploadResponse, error)

	// PostCustomerFeedbackWithBodyWithResponse request with any body
	PostCustomerFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerFeedbackResponse, error)

	PostCustomerFeedbackWithResponse(ctx context.Context, body PostCustomerFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerFeedbackResponse, error)

	// PostKycTokenWithBodyWithResponse request with any body
	PostKycTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKycTokenResponse, error)

	PostKycTokenWithResponse(ctx context.Context, body PostKycTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKycTokenResponse, error)

	// PostKycDocumentsWithBodyWithResponse request with any body
	PostKycDocumentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKycDocumentsResponse, error)

	PostKycDocumentsWithResponse(ctx context.Context, body PostKycDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKycDocumentsResponse, error)

	// PostIdentityDocumentImagesWithBodyWithResponse request with any body
	PostIdentityDocumentImagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIdentityDocumentImagesResponse, error)

	PostIdentityDocumentImagesWithResponse(ctx context.Context, body PostIdentityDocumentImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIdentityDocumentImagesResponse, error)

	// GetIdentityDocumentWithResponse request
	GetIdentityDocumentWithResponse(ctx context.Context, id string, params *GetIdentityDocumentParams, reqEditors ...RequestEditorFn) (*GetIdentityDocumentResponse, error)

	// PostCardsAuthorizationsWithBodyWithResponse request with any body
	PostCardsAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCardsAuthorizationsResponse, error)

	PostCardsAuthorizationsWithResponse(ctx context.Context, body PostCardsAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCardsAuthorizationsResponse, error)

	// DeleteMonitoringDataWithResponse request
	DeleteMonitoringDataWithResponse(ctx context.Context, params *DeleteMonitoringDataParams, reqEditors ...RequestEditorFn) (*DeleteMonitoringDataResponse, error)

	// GetRulesWithResponse request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// GetRuleDetailsWithResponse request
	GetRuleDetailsWithResponse(ctx context.Context, params *GetRuleDetailsParams, reqEditors ...RequestEditorFn) (*GetRuleDetailsResponse, error)

	// GetSanctionAlertsWithBodyWithResponse request with any body
	GetSanctionAlertsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSanctionAlertsResponse, error)

	GetSanctionAlertsWithResponse(ctx context.Context, body GetSanctionAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSanctionAlertsResponse, error)

	// NewSubaccountWithBodyWithResponse request with any body
	NewSubaccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSubaccountResponse, error)

	NewSubaccountWithResponse(ctx context.Context, body NewSubaccountJSONRequestBody, reqEditors ...RequestEditorFn) (*NewSubaccountResponse, error)

	// NewSubaccount1WithBodyWithResponse request with any body
	NewSubaccount1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSubaccount1Response, error)

	NewSubaccount1WithResponse(ctx context.Context, body NewSubaccount1JSONRequestBody, reqEditors ...RequestEditorFn) (*NewSubaccount1Response, error)

	// V2DevicesWithBodyWithResponse request with any body
	V2DevicesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V2DevicesResponse, error)

	V2DevicesWithResponse(ctx context.Context, body V2DevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*V2DevicesResponse, error)
}

type PostPlaidProcessorTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Successful requst message
		Status *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		// Status Invalid request message
		Status *string `json:"status,omitempty"`
	}
	JSON409 *struct {
		// Status Duplicate request message
		Status *string `json:"status,omitempty"`
	}
	JSON500 *struct {
		// Message Failed request message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostPlaidProcessorTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPlaidProcessorTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlaidDataSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Successful requst message
		Status *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		// PlaidError Error details provided by Plaid
		PlaidError *struct {
			// DisplayMessage A user-friendly representation of the error code. null if the error is not related to user action.
			DisplayMessage *string `json:"display_message,omitempty"`

			// ErrorCode The particular error code. Safe for programmatic use.
			ErrorCode *string `json:"error_code,omitempty"`

			// ErrorMessage A developer-friendly representation of the error code. This may change over time and is not safe for programmatic use.
			ErrorMessage *string `json:"error_message,omitempty"`

			// ErrorType A broad categorization of the error. Safe for programmatic use.
			ErrorType *string `json:"error_type,omitempty"`

			// RequestId A unique ID identifying the request, to be used for troubleshooting purposes.
			RequestId *string `json:"request_id,omitempty"`
		} `json:"plaidError,omitempty"`

		// Status Invalid request message
		Status *string `json:"status,omitempty"`
	}
	JSON500 *struct {
		// Message Failed request message
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PlaidDataSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlaidDataSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllowlistClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ClientId Account client ID of allowlist where item was added
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the allowlist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the allowlisting request
			Reason *GetAllowlistClient200DataReason `json:"reason,omitempty"`

			// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
			RuleIds *[]int                          `json:"ruleIds,omitempty"`
			Scope   *GetAllowlistClient200DataScope `json:"scope,omitempty"`
			Type    *GetAllowlistClient200DataType  `json:"type,omitempty"`

			// Value The value of the allowlisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
}
type GetAllowlistClient200DataReason string
type GetAllowlistClient200DataScope string
type GetAllowlistClient200DataType string

// Status returns HTTPResponse.Status
func (r GetAllowlistClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllowlistClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAllowListCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ClientId Account client ID of allowlist where item was added
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the allowlist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the allowlisting request
			Reason *PostAllowListCreate200DataReason `json:"reason,omitempty"`

			// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
			RuleIds *[]int                           `json:"ruleIds,omitempty"`
			Scope   *PostAllowListCreate200DataScope `json:"scope,omitempty"`
			Type    *PostAllowListCreate200DataType  `json:"type,omitempty"`

			// Value The value of the allowlisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
}
type PostAllowListCreate200DataReason string
type PostAllowListCreate200DataScope string
type PostAllowListCreate200DataType string

// Status returns HTTPResponse.Status
func (r PostAllowListCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAllowListCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAllowlistExpireResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ClientId Account client ID of allowlist where item was added
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the allowlist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the allowlisting request
			Reason *PostAllowlistExpire200DataReason `json:"reason,omitempty"`

			// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
			RuleIds *[]int                           `json:"ruleIds,omitempty"`
			Scope   *PostAllowlistExpire200DataScope `json:"scope,omitempty"`
			Type    *PostAllowlistExpire200DataType  `json:"type,omitempty"`

			// Value The value of the allowlisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}
type PostAllowlistExpire200DataReason string
type PostAllowlistExpire200DataScope string
type PostAllowlistExpire200DataType string

// Status returns HTTPResponse.Status
func (r PostAllowlistExpireResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAllowlistExpireResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAllowlistFindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ClientId Account client ID of allowlist where item was added
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the allowlist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the allowlisting request
			Reason *PostAllowlistFind200DataReason `json:"reason,omitempty"`

			// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
			RuleIds *[]int                         `json:"ruleIds,omitempty"`
			Scope   *PostAllowlistFind200DataScope `json:"scope,omitempty"`
			Type    *PostAllowlistFind200DataType  `json:"type,omitempty"`

			// Value The value of the allowlisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
}
type PostAllowlistFind200DataReason string
type PostAllowlistFind200DataScope string
type PostAllowlistFind200DataType string

// Status returns HTTPResponse.Status
func (r PostAllowlistFindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAllowlistFindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBankTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
		SessionKey *string `json:"sessionKey,omitempty"`

		// Status always returns "Success" for successful response
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBankTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBankTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the blocklist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the blocklisting request.
			Reason *GetClientBlocklists200DataReason `json:"reason,omitempty"`
			Scope  *GetClientBlocklists200DataScope  `json:"scope,omitempty"`

			// Type The type of item to be blocklisted.
			Type *GetClientBlocklists200DataType `json:"type,omitempty"`

			// Value The value of the blocklisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
}
type GetClientBlocklists200DataReason string
type GetClientBlocklists200DataScope string
type GetClientBlocklists200DataType string

// Status returns HTTPResponse.Status
func (r GetClientBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClientBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the blocklist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the blocklisting request.
			Reason *PostClientBlocklists200DataReason `json:"reason,omitempty"`
			Scope  *PostClientBlocklists200DataScope  `json:"scope,omitempty"`

			// Type The type of item to be blocklisted.
			Type *PostClientBlocklists200DataType `json:"type,omitempty"`

			// Value The value of the blocklisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
}
type PostClientBlocklists200DataReason string
type PostClientBlocklists200DataScope string
type PostClientBlocklists200DataType string

// Status returns HTTPResponse.Status
func (r PostClientBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClientBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBlockListExpireResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the blocklist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the blocklisting request.
			Reason *PostBlockListExpire200DataReason `json:"reason,omitempty"`
			Scope  *PostBlockListExpire200DataScope  `json:"scope,omitempty"`

			// Type The type of item to be blocklisted.
			Type *PostBlockListExpire200DataType `json:"type,omitempty"`

			// Value The value of the blocklisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}
type PostBlockListExpire200DataReason string
type PostBlockListExpire200DataScope string
type PostBlockListExpire200DataType string

// Status returns HTTPResponse.Status
func (r PostBlockListExpireResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBlockListExpireResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSpecificBlockListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
			ClientId *string `json:"client_id,omitempty"`

			// Comment Optional comment provided when item was added to the blocklist.
			Comment *string `json:"comment,omitempty"`

			// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
			Expiry *float32 `json:"expiry,omitempty"`
			Id     *float32 `json:"id,omitempty"`

			// Reason Source of the blocklisting request.
			Reason *PostSpecificBlockList200DataReason `json:"reason,omitempty"`
			Scope  *PostSpecificBlockList200DataScope  `json:"scope,omitempty"`

			// Type The type of item to be blocklisted.
			Type *PostSpecificBlockList200DataType `json:"type,omitempty"`

			// Value The value of the blocklisted item.
			Value *string `json:"value,omitempty"`
		} `json:"data,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}
type PostSpecificBlockList200DataReason string
type PostSpecificBlockList200DataScope string
type PostSpecificBlockList200DataType string

// Status returns HTTPResponse.Status
func (r PostSpecificBlockListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSpecificBlockListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetbixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ClientID Unique identifier for your Sardine account this KYB check was run on
		ClientID *string               `json:"clientID,omitempty"`
		Config   *BizConfigGetResponse `json:"config,omitempty"`

		// CustomerIds List of business owners' customer IDs
		CustomerIds *[]string `json:"customerIds,omitempty"`

		// Id The Sardine specific identifier
		Id  *int32 `json:"id,omitempty"`
		Kyb *struct {
			Address        *[]BizAddress `json:"address,omitempty"`
			Alias          *[]string     `json:"alias,omitempty"`
			FormationState *string       `json:"formationState,omitempty"`
			Tasks          *[]struct {
				Category *string `json:"category,omitempty"`
				Label    *string `json:"label,omitempty"`
				Message  *string `json:"message,omitempty"`
				Name     *string `json:"name,omitempty"`
				Sources  *[]struct {
					Metadata *struct {
						Name      *string `json:"name,omitempty"`
						Submitted *bool   `json:"submitted,omitempty"`
					} `json:"metadata,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"sources,omitempty"`
				Status   *string `json:"status,omitempty"`
				SubLabel *string `json:"subLabel,omitempty"`
				Type     *string `json:"type,omitempty"`
			} `json:"tasks,omitempty"`
		} `json:"kyb,omitempty"`

		// Name Name of the business
		Name *string `json:"name,omitempty"`

		// RuleExecutedAt Timestamp in milliseconds when the business verification rules were executed
		RuleExecutedAt *int64 `json:"ruleExecutedAt,omitempty"`

		// RuleMatched List of business rules that triggered on this business verification
		RuleMatched *[]int64 `json:"ruleMatched,omitempty"`

		// RuleNotMatched List of business rules that did not triggered on this business verification
		RuleNotMatched *[]int64 `json:"ruleNotMatched,omitempty"`

		// Status Status of the business verification
		Status *Getbix200Status `json:"status,omitempty"`

		// TrackingId Your unique identifier for this business
		TrackingId *string `json:"trackingId,omitempty"`

		// UpdatedAt Timestamp in milliseconds when the business verification was last updated
		UpdatedAt *int64 `json:"updatedAt,omitempty"`

		// Website Website of the business
		Website *string `json:"website,omitempty"`
	}
	JSON401 *struct {
		// Reason Reason for failed API request
		Reason *string `json:"reason,omitempty"`

		// Status Status of the authentication request
		Status *string `json:"status,omitempty"`
	}
	JSON404 *struct {
		// Error Details on reason for error message
		Error *string `json:"error,omitempty"`
	}
}
type Getbix200Status string

// Status returns HTTPResponse.Status
func (r GetbixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetbixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBizResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SardineID The Sardine specific identifier
		SardineID *string `json:"sardineID,omitempty"`
	}
	JSON400 *struct {
		// Error Invalid API input error details message
		Error *string `json:"error,omitempty"`
	}
	JSON401 *struct {
		// Reason Reason for failed API request
		Reason *string `json:"reason,omitempty"`

		// Status Status of the authentication request
		Status *string `json:"status,omitempty"`
	}
	JSON424 *struct {
		// Error Details on reason for error message
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateBizResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBizResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUpdateBizResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmlEntities This object is only avaliable if you use advancedAmlScreening in synchronous mode.
		AmlEntities *[]struct {
			AdverseMedia *struct {
				// Level Adverse media level
				Level   *AddUpdateBiz200AmlEntitiesAdverseMediaLevel `json:"level,omitempty"`
				Sources *[]struct {
					// Category Category of the adverse media
					Category *string `json:"category,omitempty"`

					// Description Description of the adverse media
					Description *string `json:"description,omitempty"`

					// SourceName Name of the adverse media source
					SourceName *string `json:"sourceName,omitempty"`

					// SourceUrl URL to the source of the adverse media
					SourceUrl *string `json:"sourceUrl,omitempty"`

					// SubCategory Sub-category of the adverse media
					SubCategory *string `json:"subCategory,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"adverseMedia,omitempty"`
			CountryCodes *[]string `json:"countryCodes,omitempty"`

			// EntityName Name of the entity
			EntityName *string `json:"entityName,omitempty"`

			// MatchScore Match score indicating the likelihood of a match (0-100 with 100 highest match)
			MatchScore *int `json:"matchScore,omitempty"`
			Pep        *struct {
				// Level Pep level
				Level   *AddUpdateBiz200AmlEntitiesPepLevel `json:"level,omitempty"`
				Sources *[]struct {
					// Description Description of the Pep
					Description *string `json:"description,omitempty"`

					// SourceName Name of the Pep source
					SourceName *string `json:"sourceName,omitempty"`

					// SourceUrl URL to the source of the Pep
					SourceUrl *string `json:"sourceUrl,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"pep,omitempty"`

			// RiskLevel Risk level associated with the entity
			RiskLevel *AddUpdateBiz200AmlEntitiesRiskLevel `json:"riskLevel,omitempty"`

			// RiskScore Risk score associated with the entity (0-100 with 100 highest risk)
			RiskScore *int `json:"riskScore,omitempty"`
			Sanction  *struct {
				// Level Sanction level
				Level   *AddUpdateBiz200AmlEntitiesSanctionLevel `json:"level,omitempty"`
				Sources *[]struct {
					// Description Description of the sanction
					Description *string `json:"description,omitempty"`

					// SourceName Name of the sanction source
					SourceName *string `json:"sourceName,omitempty"`

					// SourceUrl URL to the source of the sanction
					SourceUrl *string `json:"sourceUrl,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"sanction,omitempty"`
		} `json:"amlEntities,omitempty"`

		// SardineID The Sardine specific identifier
		SardineID *string `json:"sardineID,omitempty"`
	}
	JSON400 *struct {
		// Error Invalid API input error details message
		Error *string `json:"error,omitempty"`
	}
	JSON401 *struct {
		// Reason Reason for failed API request
		Reason *string `json:"reason,omitempty"`

		// Status Status of the authentication request
		Status *string `json:"status,omitempty"`
	}
	JSON404 *struct {
		// Error Details on reason for error message
		Error *string `json:"error,omitempty"`
	}
}
type AddUpdateBiz200AmlEntitiesAdverseMediaLevel string
type AddUpdateBiz200AmlEntitiesPepLevel string
type AddUpdateBiz200AmlEntitiesRiskLevel string
type AddUpdateBiz200AmlEntitiesSanctionLevel string

// Status returns HTTPResponse.Status
func (r AddUpdateBizResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUpdateBizResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV1BusinessesScreeningPmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor Cursor for the next page of results
		NextCursor *int `json:"nextCursor,omitempty"`
		Results    *[]struct {
			// AmlEntities This object is only avaliable if you use advancedAmlScreening in synchronous mode.
			AmlEntities *BizAmlEntities `json:"amlEntities,omitempty"`

			// SardineID Unique Sardine identifier for the business
			SardineID *int `json:"sardineID,omitempty"`

			// TrackingID Unique identifier as defined by you in the original screening request
			TrackingID *string `json:"trackingID,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostV1BusinessesScreeningPmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV1BusinessesScreeningPmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AssignedTo Sardine dashboard user the case has been assigned to
		AssignedTo *string `json:"assignedTo,omitempty"`

		// CaseDecision Latest decision of the case
		CaseDecision *string `json:"caseDecision,omitempty"`

		// CaseDecisionLabelId Sardine identifier for the decision value
		CaseDecisionLabelId *string `json:"caseDecisionLabelId,omitempty"`

		// CaseDescription Description of the case
		CaseDescription *string `json:"caseDescription,omitempty"`

		// CaseName Name assigned to case
		CaseName *string `json:"caseName,omitempty"`

		// CaseStatus Latest status of the case
		CaseStatus *GetCase200CaseStatus `json:"caseStatus,omitempty"`

		// ClientID Sardine account identifier the case belongs to
		ClientID *string `json:"clientID,omitempty"`

		// ContinuingReportTimer Timestamp when case continuing report timer
		ContinuingReportTimer *int64 `json:"continuingReportTimer,omitempty"`

		// CreatedAt Timestamp when case was created
		CreatedAt *int64 `json:"createdAt,omitempty"`

		// Documents Details of files uploaded to the case
		Documents *[]struct {
			// DocumentID Sardine identifier for the uploaded file
			DocumentID *string `json:"documentID,omitempty"`

			// DocumentName Name of the uploaded file
			DocumentName *string `json:"documentName,omitempty"`

			// DocumentPath Path to access the uploaded file
			DocumentPath *string `json:"documentPath,omitempty"`
		} `json:"documents,omitempty"`

		// ExtensionTimer Timestamp when case extension timer
		ExtensionTimer *int64 `json:"extensionTimer,omitempty"`

		// Id Sardine case identifier
		Id *int64 `json:"id,omitempty"`

		// InitialTimer Timestamp when case initial timer
		InitialTimer *int64 `json:"initialTimer,omitempty"`

		// LinkedBusinesses List of business IDs this case is linked to
		LinkedBusinesses *[]string `json:"linkedBusinesses,omitempty"`

		// LinkedCustomer List of customer IDs this case is linked to
		LinkedCustomer *[]string `json:"linkedCustomer,omitempty"`

		// LinkedReviews List of review IDs this case is linked to
		LinkedReviews *[]string `json:"linkedReviews,omitempty"`

		// LinkedTransaction List of transaction IDs this case is linked to
		LinkedTransaction *[]string `json:"linkedTransaction,omitempty"`

		// UpdatedAt Timestamp when case was last updated
		UpdatedAt *int64 `json:"updatedAt,omitempty"`
	}
}
type GetCase200CaseStatus string

// Status returns HTTPResponse.Status
func (r GetCaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewCaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CaseID Sardine identifier for the case
		CaseID *string `json:"caseID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewCaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewCaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CaseID Sardine identifier for the case
		CaseID *string `json:"caseID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ClientList `json:"data,omitempty"`

		// Message Status message for the custom list request.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCustomListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomListDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Status of the deletion request.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCustomListDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomListDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNewListItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Status of the deletion request.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNewListItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNewListItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostItemsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status Status of the deletion request.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostItemsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostItemsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomListRetrieveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ClientList `json:"data,omitempty"`

		// Message Status message for the custom list request.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomListRetrieveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomListRetrieveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CheckpointData List of checkpoints run for this session
		CheckpointData *CheckpointDataResponse `json:"checkpointData,omitempty"`

		// Checkpoints Result of rule evaluations for each checkpoint. `customer` checkpoint is executed by default.
		Checkpoints  *CheckPointsResponse `json:"checkpoints,omitempty"`
		Counterparty *struct {
			AmlEntities   *[]AmlEntity `json:"amlEntities,omitempty"`
			PaymentMethod *struct {
				AmlEntities *[]AmlEntity `json:"amlEntities,omitempty"`
			} `json:"paymentMethod,omitempty"`
		} `json:"counterparty,omitempty"`

		// Customer customer riskiness level and associated signals
		Customer *CustomerResponse `json:"customer,omitempty"`

		// Device Device riskiness level and associated signals
		Device *DevicesResponse `json:"device,omitempty"`

		// Level Risk at overall level: "very_high", "high", "medium", "low". This is the top-level field that you can use to make a risk decision. It is max of customer.level and device.level
		Level *string `json:"level,omitempty"`

		// Rules List of live and shadow rules that triggered for this session
		Rules *RulesResponse `json:"rules,omitempty"`

		// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
		SessionKey *string `json:"sessionKey,omitempty"`

		// Status status of the API response
		Status *PostCustomerInformation200Status `json:"status,omitempty"`

		// Transaction transaction related information
		Transaction *TransactionResponse `json:"transaction,omitempty"`

		// Workflow workflow excecution output data if a workflowName was provided in the request
		Workflow *WorkflowResponse `json:"workflow,omitempty"`
	}
	JSON400 *struct {
		// Message Details on reason for API error
		Message *string `json:"message,omitempty"`

		// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
		SessionKey *string `json:"sessionKey,omitempty"`
	}
	JSON401 *struct {
		// Reason Details on reason for API error
		Reason *string `json:"reason,omitempty"`

		// Status status of the API response
		Status *PostCustomerInformation401Status `json:"status,omitempty"`
	}
	JSON422 *struct {
		// Message Details on reason for API error
		Message *string `json:"message,omitempty"`

		// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
		SessionKey *string `json:"sessionKey,omitempty"`
	}
}
type PostCustomerInformation200Status string
type PostCustomerInformation401Status string

// Status returns HTTPResponse.Status
func (r PostCustomerInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersDeletionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostCustomersDeletionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersDeletionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDocumentUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FileResults *[]struct {
			DocumentId *string `json:"document_id,omitempty"`
			Tag        *string `json:"tag,omitempty"`
		} `json:"file_results,omitempty"`

		// Status Status of the upload request.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDocumentUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDocumentUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Status always returns "success" for successful response
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCustomerFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostKycTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken jwt token for the process
		AccessToken *string `json:"access_token,omitempty"`

		// ExpiresIn Expiry of the token
		ExpiresIn *int `json:"expires_in,omitempty"`

		// IncodeSdkBaseUrl base url to initialized Incode SDK.
		IncodeSdkBaseUrl *string `json:"incode_sdk_base_url,omitempty"`

		// Scope scope of the token to be used.
		Scope *string `json:"scope,omitempty"`

		// TokenType type of the token
		TokenType *string `json:"token_type,omitempty"`

		// VerificationId verification id of the session
		VerificationId *string `json:"verification_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostKycTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostKycTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostKycDocumentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id id of the document kyc process
		Id   *string `json:"id,omitempty"`
		Link *struct {
			// ExpiredAt Expiry of the url
			ExpiredAt *string `json:"expiredAt,omitempty"`

			// Url Url to perform doc kyc
			Url *string `json:"url,omitempty"`
		} `json:"link,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostKycDocumentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostKycDocumentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostIdentityDocumentImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Back base64 string of the back of the ID document associated with the verificationId (if collected)
		Back *string `json:"back,omitempty"`

		// Front base64 string of the back of the ID document associated with the verificationId (if collected)
		Front *string `json:"front,omitempty"`

		// Selfie base64 string of the selfie image associated with the verificationId (if collected)
		Selfie *string `json:"selfie,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostIdentityDocumentImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostIdentityDocumentImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DocumentData data extracted from the document
		DocumentData *struct {
			// Address address written on the document
			Address *string `json:"address,omitempty"`

			// DateOfBirth date of birth, returned as YYYY-MM-DD format
			DateOfBirth *string `json:"dateOfBirth,omitempty"`

			// DateOfExpiry date of document expiration
			DateOfExpiry *string `json:"dateOfExpiry,omitempty"`

			// DateOfIssue date of document issued
			DateOfIssue *string `json:"dateOfIssue,omitempty"`

			// FirstName first name
			FirstName *string `json:"firstName,omitempty"`

			// Gender male, female, or other
			Gender *string `json:"gender,omitempty"`

			// IssuingCountry issuing country, in 2-digit ISO code
			IssuingCountry *string `json:"issuingCountry,omitempty"`

			// LastName last name
			LastName *string `json:"lastName,omitempty"`

			// MiddleName middle name
			MiddleName *string `json:"middleName,omitempty"`

			// Number number of the document
			Number *string `json:"number,omitempty"`

			// Type type of ID document: `Unknown`,  `Passport`, `Visa`, `DriversLicense`, `IdentificationCard`, `Permit` , `ResidenceDocument` ,  `TravelDocument` , `BirthCertificate` ,  `VehicleRegistration` , `Other` ,  `WeaponLicense` ,  `TribalIdentification` ,  `VoterIdentification` , and `Military`
			Type *string `json:"type,omitempty"`
		} `json:"documentData,omitempty"`

		// ErrorCodes reason for processing error.
		//
		// | Code | Description |
		// |------|---------|
		// | unrecognizable_document  | Document could not be recognized, please resubmit with higher resolution image |
		// | requires_recapture  | Provided document requires recapturing |
		// | document_bad_size_or_type  | Either file size or type of provided document is not supported |
		ErrorCodes *[]string `json:"errorCodes,omitempty"`

		// Status Status of the verification. One of `pending`, `processing`, `complete` and `error`. When `error`, `errorCode` field below explains the reason for error.
		Status       string `json:"status"`
		Verification *struct {
			// DocumentMatchLevel likelihood of inputData match with the document image. `high`, `medium`, `low`, or `not_applicable`
			DocumentMatchLevel *string `json:"documentMatchLevel,omitempty"`

			// FaceMatchLevel likelihood of photo/selfie match with the document image. `high`, `medium`, `low`, `not_applicable`, or `error`
			FaceMatchLevel *string `json:"faceMatchLevel,omitempty"`

			// ForgeryLevel Indicates the likelihood of submitted document is forged. `high`, `medium`, `low`, or `unknown` The forgery level is based on a variety of checks around the integrity of the document. An `unknown` level indicates Sardine was not able to evaluate the document (e.g. non-support document type, non-successful capture of the document/selfie)
			ForgeryLevel *string `json:"forgeryLevel,omitempty"`

			// ImageQualityLevel image quality of ID document. `high`, `medium`, `low`
			ImageQualityLevel *string `json:"imageQualityLevel,omitempty"`

			// RiskLevel Overall riskiness of accepting this ID document. `high`, `medium`, `low`, or `unknown` The overall risk level of a document verification is determined by Machine Learning (ML) model tests, as well as the other individual ID tests (e.g. document crosscheck, expiration date validity, etc.). An `unknown` level indicates Sardine was not able to evaluate the document (e.g. non-support document type, non-successful capture of the document/selfie).
			RiskLevel *string `json:"riskLevel,omitempty"`
		} `json:"verification,omitempty"`

		// VerificationId ID of document verification
		VerificationId string `json:"verificationId"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIdentityDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCardsAuthorizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmlLevel AML risk level like high, medium and low.
		AmlLevel *string `json:"amlLevel,omitempty"`

		// Checkpoints Result of rule evaluations for each checkpoint. `issuingrisk` checkpoint is executed by default.
		Checkpoints *CheckPointsResponseIssuing `json:"checkpoints,omitempty"`

		// Level Risk level like very_high, high, medium and low
		Level *string `json:"level,omitempty"`

		// ReasonCodes List of reason codes returned for this session (it is omitted if empty). Example: ALWR
		ReasonCodes *[]string `json:"reasonCodes,omitempty"`

		// Rules List of live and shadow rules that triggered for this session
		Rules *RulesResponse `json:"rules,omitempty"`

		// Score ML Risk Score for this particular transaction. The ML model used to predict the score is trained on various features and can be used once sufficient data and feedback have been provided.
		Score *float32 `json:"score,omitempty"`

		// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
		SessionKey *string `json:"sessionKey,omitempty"`

		// Status Status of the API response
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostCardsAuthorizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCardsAuthorizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMonitoringDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON404 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMonitoringDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMonitoringDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Rules *[]Rules `json:"rules,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rules
}

// Status returns HTTPResponse.Status
func (r GetRuleDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSanctionAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor cursor for the next page
		NextCursor *string `json:"nextCursor,omitempty"`

		// Results if the results are null or empty you have no more results
		Results *[]struct {
			Aml *struct {
				AdverseMedia *[]AmlObject `json:"adverseMedia,omitempty"`
				Alias        *[]string    `json:"alias,omitempty"`
				CountryCodes *[]string    `json:"countryCodes,omitempty"`
				DateOfBirths *[]string    `json:"dateOfBirths,omitempty"`
				EntityName   *string      `json:"entityName,omitempty"`

				// MatchScore possible score 0 to 100 higher the better. represents how close the entity match the given data
				MatchScore *int         `json:"matchScore,omitempty"`
				Pep        *[]AmlObject `json:"pep,omitempty"`

				// RiskScore possible score 0 to 100 higher the better. represents how risky a entity is.
				RiskScore *int         `json:"riskScore,omitempty"`
				Sanction  *[]AmlObject `json:"sanction,omitempty"`
			} `json:"aml,omitempty"`

			// Signals | Name | Description |Values|
			// |--------|---------|------------
			// | sanctionLevel | Check if the customer belongs to sanction list like SDN/OFAC. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
			// | pepLevel | Check if the customer belongs to PEP(Politically Exposed Person) list. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
			// | adverseMediaLevel | Check if the customer has any associated adverse media . Only available if Sanctions Screening is enabled for your account.|high/medium/low|
			Signals *[]Signal `json:"signals,omitempty"`

			// UserIdHash user id hash, as provided by you in customers API
			UserIdHash *string `json:"userIdHash,omitempty"`
		} `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSanctionAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSanctionAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewSubaccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id ID of newly generated subaccount
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewSubaccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewSubaccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewSubaccount1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Secret generated secret for this subaccount
		Secret *string `json:"secret,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewSubaccount1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewSubaccount1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V2DevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevicesResponse
}

// Status returns HTTPResponse.Status
func (r V2DevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V2DevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostPlaidProcessorTokenWithBodyWithResponse request with arbitrary body returning *PostPlaidProcessorTokenResponse
func (c *ClientWithResponses) PostPlaidProcessorTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlaidProcessorTokenResponse, error) {
	rsp, err := c.PostPlaidProcessorTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlaidProcessorTokenResponse(rsp)
}

func (c *ClientWithResponses) PostPlaidProcessorTokenWithResponse(ctx context.Context, body PostPlaidProcessorTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlaidProcessorTokenResponse, error) {
	rsp, err := c.PostPlaidProcessorToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlaidProcessorTokenResponse(rsp)
}

// PlaidDataSyncWithBodyWithResponse request with arbitrary body returning *PlaidDataSyncResponse
func (c *ClientWithResponses) PlaidDataSyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlaidDataSyncResponse, error) {
	rsp, err := c.PlaidDataSyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaidDataSyncResponse(rsp)
}

func (c *ClientWithResponses) PlaidDataSyncWithResponse(ctx context.Context, body PlaidDataSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PlaidDataSyncResponse, error) {
	rsp, err := c.PlaidDataSync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaidDataSyncResponse(rsp)
}

// GetAllowlistClientWithResponse request returning *GetAllowlistClientResponse
func (c *ClientWithResponses) GetAllowlistClientWithResponse(ctx context.Context, params *GetAllowlistClientParams, reqEditors ...RequestEditorFn) (*GetAllowlistClientResponse, error) {
	rsp, err := c.GetAllowlistClient(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllowlistClientResponse(rsp)
}

// PostAllowListCreateWithBodyWithResponse request with arbitrary body returning *PostAllowListCreateResponse
func (c *ClientWithResponses) PostAllowListCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowListCreateResponse, error) {
	rsp, err := c.PostAllowListCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowListCreateResponse(rsp)
}

func (c *ClientWithResponses) PostAllowListCreateWithResponse(ctx context.Context, body PostAllowListCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowListCreateResponse, error) {
	rsp, err := c.PostAllowListCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowListCreateResponse(rsp)
}

// PostAllowlistExpireWithBodyWithResponse request with arbitrary body returning *PostAllowlistExpireResponse
func (c *ClientWithResponses) PostAllowlistExpireWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowlistExpireResponse, error) {
	rsp, err := c.PostAllowlistExpireWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowlistExpireResponse(rsp)
}

func (c *ClientWithResponses) PostAllowlistExpireWithResponse(ctx context.Context, body PostAllowlistExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowlistExpireResponse, error) {
	rsp, err := c.PostAllowlistExpire(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowlistExpireResponse(rsp)
}

// PostAllowlistFindWithBodyWithResponse request with arbitrary body returning *PostAllowlistFindResponse
func (c *ClientWithResponses) PostAllowlistFindWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAllowlistFindResponse, error) {
	rsp, err := c.PostAllowlistFindWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowlistFindResponse(rsp)
}

func (c *ClientWithResponses) PostAllowlistFindWithResponse(ctx context.Context, body PostAllowlistFindJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAllowlistFindResponse, error) {
	rsp, err := c.PostAllowlistFind(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAllowlistFindResponse(rsp)
}

// PostBankTransactionsWithBodyWithResponse request with arbitrary body returning *PostBankTransactionsResponse
func (c *ClientWithResponses) PostBankTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBankTransactionsResponse, error) {
	rsp, err := c.PostBankTransactionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBankTransactionsResponse(rsp)
}

func (c *ClientWithResponses) PostBankTransactionsWithResponse(ctx context.Context, body PostBankTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBankTransactionsResponse, error) {
	rsp, err := c.PostBankTransactions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBankTransactionsResponse(rsp)
}

// GetClientBlocklistsWithResponse request returning *GetClientBlocklistsResponse
func (c *ClientWithResponses) GetClientBlocklistsWithResponse(ctx context.Context, params *GetClientBlocklistsParams, reqEditors ...RequestEditorFn) (*GetClientBlocklistsResponse, error) {
	rsp, err := c.GetClientBlocklists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientBlocklistsResponse(rsp)
}

// PostClientBlocklistsWithBodyWithResponse request with arbitrary body returning *PostClientBlocklistsResponse
func (c *ClientWithResponses) PostClientBlocklistsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClientBlocklistsResponse, error) {
	rsp, err := c.PostClientBlocklistsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientBlocklistsResponse(rsp)
}

func (c *ClientWithResponses) PostClientBlocklistsWithResponse(ctx context.Context, body PostClientBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClientBlocklistsResponse, error) {
	rsp, err := c.PostClientBlocklists(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClientBlocklistsResponse(rsp)
}

// PostBlockListExpireWithBodyWithResponse request with arbitrary body returning *PostBlockListExpireResponse
func (c *ClientWithResponses) PostBlockListExpireWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBlockListExpireResponse, error) {
	rsp, err := c.PostBlockListExpireWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlockListExpireResponse(rsp)
}

func (c *ClientWithResponses) PostBlockListExpireWithResponse(ctx context.Context, body PostBlockListExpireJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBlockListExpireResponse, error) {
	rsp, err := c.PostBlockListExpire(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBlockListExpireResponse(rsp)
}

// PostSpecificBlockListWithBodyWithResponse request with arbitrary body returning *PostSpecificBlockListResponse
func (c *ClientWithResponses) PostSpecificBlockListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSpecificBlockListResponse, error) {
	rsp, err := c.PostSpecificBlockListWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSpecificBlockListResponse(rsp)
}

func (c *ClientWithResponses) PostSpecificBlockListWithResponse(ctx context.Context, body PostSpecificBlockListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSpecificBlockListResponse, error) {
	rsp, err := c.PostSpecificBlockList(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSpecificBlockListResponse(rsp)
}

// GetbixWithResponse request returning *GetbixResponse
func (c *ClientWithResponses) GetbixWithResponse(ctx context.Context, params *GetbixParams, reqEditors ...RequestEditorFn) (*GetbixResponse, error) {
	rsp, err := c.Getbix(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetbixResponse(rsp)
}

// UpdateBizWithBodyWithResponse request with arbitrary body returning *UpdateBizResponse
func (c *ClientWithResponses) UpdateBizWithBodyWithResponse(ctx context.Context, params *UpdateBizParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBizResponse, error) {
	rsp, err := c.UpdateBizWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBizResponse(rsp)
}

func (c *ClientWithResponses) UpdateBizWithResponse(ctx context.Context, params *UpdateBizParams, body UpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBizResponse, error) {
	rsp, err := c.UpdateBiz(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBizResponse(rsp)
}

// AddUpdateBizWithBodyWithResponse request with arbitrary body returning *AddUpdateBizResponse
func (c *ClientWithResponses) AddUpdateBizWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUpdateBizResponse, error) {
	rsp, err := c.AddUpdateBizWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUpdateBizResponse(rsp)
}

func (c *ClientWithResponses) AddUpdateBizWithResponse(ctx context.Context, body AddUpdateBizJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUpdateBizResponse, error) {
	rsp, err := c.AddUpdateBiz(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUpdateBizResponse(rsp)
}

// PostV1BusinessesScreeningPmsWithBodyWithResponse request with arbitrary body returning *PostV1BusinessesScreeningPmsResponse
func (c *ClientWithResponses) PostV1BusinessesScreeningPmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV1BusinessesScreeningPmsResponse, error) {
	rsp, err := c.PostV1BusinessesScreeningPmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1BusinessesScreeningPmsResponse(rsp)
}

func (c *ClientWithResponses) PostV1BusinessesScreeningPmsWithResponse(ctx context.Context, body PostV1BusinessesScreeningPmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV1BusinessesScreeningPmsResponse, error) {
	rsp, err := c.PostV1BusinessesScreeningPms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV1BusinessesScreeningPmsResponse(rsp)
}

// GetCaseWithResponse request returning *GetCaseResponse
func (c *ClientWithResponses) GetCaseWithResponse(ctx context.Context, params *GetCaseParams, reqEditors ...RequestEditorFn) (*GetCaseResponse, error) {
	rsp, err := c.GetCase(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaseResponse(rsp)
}

// NewCaseWithBodyWithResponse request with arbitrary body returning *NewCaseResponse
func (c *ClientWithResponses) NewCaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCaseResponse, error) {
	rsp, err := c.NewCaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCaseResponse(rsp)
}

func (c *ClientWithResponses) NewCaseWithResponse(ctx context.Context, body NewCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCaseResponse, error) {
	rsp, err := c.NewCase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCaseResponse(rsp)
}

// UpdateCaseWithBodyWithResponse request with arbitrary body returning *UpdateCaseResponse
func (c *ClientWithResponses) UpdateCaseWithBodyWithResponse(ctx context.Context, params *UpdateCaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaseResponse, error) {
	rsp, err := c.UpdateCaseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateCaseWithResponse(ctx context.Context, params *UpdateCaseParams, body UpdateCaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaseResponse, error) {
	rsp, err := c.UpdateCase(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaseResponse(rsp)
}

// PostCustomListWithBodyWithResponse request with arbitrary body returning *PostCustomListResponse
func (c *ClientWithResponses) PostCustomListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomListResponse, error) {
	rsp, err := c.PostCustomListWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomListResponse(rsp)
}

func (c *ClientWithResponses) PostCustomListWithResponse(ctx context.Context, body PostCustomListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomListResponse, error) {
	rsp, err := c.PostCustomList(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomListResponse(rsp)
}

// PostCustomListDeleteWithBodyWithResponse request with arbitrary body returning *PostCustomListDeleteResponse
func (c *ClientWithResponses) PostCustomListDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomListDeleteResponse, error) {
	rsp, err := c.PostCustomListDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomListDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostCustomListDeleteWithResponse(ctx context.Context, body PostCustomListDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomListDeleteResponse, error) {
	rsp, err := c.PostCustomListDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomListDeleteResponse(rsp)
}

// PostNewListItemsWithBodyWithResponse request with arbitrary body returning *PostNewListItemsResponse
func (c *ClientWithResponses) PostNewListItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNewListItemsResponse, error) {
	rsp, err := c.PostNewListItemsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNewListItemsResponse(rsp)
}

func (c *ClientWithResponses) PostNewListItemsWithResponse(ctx context.Context, body PostNewListItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNewListItemsResponse, error) {
	rsp, err := c.PostNewListItems(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNewListItemsResponse(rsp)
}

// PostItemsDeleteWithBodyWithResponse request with arbitrary body returning *PostItemsDeleteResponse
func (c *ClientWithResponses) PostItemsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostItemsDeleteResponse, error) {
	rsp, err := c.PostItemsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostItemsDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostItemsDeleteWithResponse(ctx context.Context, body PostItemsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostItemsDeleteResponse, error) {
	rsp, err := c.PostItemsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostItemsDeleteResponse(rsp)
}

// GetCustomListRetrieveWithResponse request returning *GetCustomListRetrieveResponse
func (c *ClientWithResponses) GetCustomListRetrieveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCustomListRetrieveResponse, error) {
	rsp, err := c.GetCustomListRetrieve(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomListRetrieveResponse(rsp)
}

// PostCustomerInformationWithBodyWithResponse request with arbitrary body returning *PostCustomerInformationResponse
func (c *ClientWithResponses) PostCustomerInformationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerInformationResponse, error) {
	rsp, err := c.PostCustomerInformationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerInformationResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerInformationWithResponse(ctx context.Context, body PostCustomerInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerInformationResponse, error) {
	rsp, err := c.PostCustomerInformation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerInformationResponse(rsp)
}

// PostCustomersDeletionsWithBodyWithResponse request with arbitrary body returning *PostCustomersDeletionsResponse
func (c *ClientWithResponses) PostCustomersDeletionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersDeletionsResponse, error) {
	rsp, err := c.PostCustomersDeletionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersDeletionsResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersDeletionsWithResponse(ctx context.Context, body PostCustomersDeletionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersDeletionsResponse, error) {
	rsp, err := c.PostCustomersDeletions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersDeletionsResponse(rsp)
}

// PostDocumentUploadWithBodyWithResponse request with arbitrary body returning *PostDocumentUploadResponse
func (c *ClientWithResponses) PostDocumentUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDocumentUploadResponse, error) {
	rsp, err := c.PostDocumentUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDocumentUploadResponse(rsp)
}

// PostCustomerFeedbackWithBodyWithResponse request with arbitrary body returning *PostCustomerFeedbackResponse
func (c *ClientWithResponses) PostCustomerFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerFeedbackResponse, error) {
	rsp, err := c.PostCustomerFeedbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerFeedbackResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerFeedbackWithResponse(ctx context.Context, body PostCustomerFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerFeedbackResponse, error) {
	rsp, err := c.PostCustomerFeedback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerFeedbackResponse(rsp)
}

// PostKycTokenWithBodyWithResponse request with arbitrary body returning *PostKycTokenResponse
func (c *ClientWithResponses) PostKycTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKycTokenResponse, error) {
	rsp, err := c.PostKycTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKycTokenResponse(rsp)
}

func (c *ClientWithResponses) PostKycTokenWithResponse(ctx context.Context, body PostKycTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKycTokenResponse, error) {
	rsp, err := c.PostKycToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKycTokenResponse(rsp)
}

// PostKycDocumentsWithBodyWithResponse request with arbitrary body returning *PostKycDocumentsResponse
func (c *ClientWithResponses) PostKycDocumentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKycDocumentsResponse, error) {
	rsp, err := c.PostKycDocumentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKycDocumentsResponse(rsp)
}

func (c *ClientWithResponses) PostKycDocumentsWithResponse(ctx context.Context, body PostKycDocumentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKycDocumentsResponse, error) {
	rsp, err := c.PostKycDocuments(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKycDocumentsResponse(rsp)
}

// PostIdentityDocumentImagesWithBodyWithResponse request with arbitrary body returning *PostIdentityDocumentImagesResponse
func (c *ClientWithResponses) PostIdentityDocumentImagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIdentityDocumentImagesResponse, error) {
	rsp, err := c.PostIdentityDocumentImagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIdentityDocumentImagesResponse(rsp)
}

func (c *ClientWithResponses) PostIdentityDocumentImagesWithResponse(ctx context.Context, body PostIdentityDocumentImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIdentityDocumentImagesResponse, error) {
	rsp, err := c.PostIdentityDocumentImages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIdentityDocumentImagesResponse(rsp)
}

// GetIdentityDocumentWithResponse request returning *GetIdentityDocumentResponse
func (c *ClientWithResponses) GetIdentityDocumentWithResponse(ctx context.Context, id string, params *GetIdentityDocumentParams, reqEditors ...RequestEditorFn) (*GetIdentityDocumentResponse, error) {
	rsp, err := c.GetIdentityDocument(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityDocumentResponse(rsp)
}

// PostCardsAuthorizationsWithBodyWithResponse request with arbitrary body returning *PostCardsAuthorizationsResponse
func (c *ClientWithResponses) PostCardsAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCardsAuthorizationsResponse, error) {
	rsp, err := c.PostCardsAuthorizationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCardsAuthorizationsResponse(rsp)
}

func (c *ClientWithResponses) PostCardsAuthorizationsWithResponse(ctx context.Context, body PostCardsAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCardsAuthorizationsResponse, error) {
	rsp, err := c.PostCardsAuthorizations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCardsAuthorizationsResponse(rsp)
}

// DeleteMonitoringDataWithResponse request returning *DeleteMonitoringDataResponse
func (c *ClientWithResponses) DeleteMonitoringDataWithResponse(ctx context.Context, params *DeleteMonitoringDataParams, reqEditors ...RequestEditorFn) (*DeleteMonitoringDataResponse, error) {
	rsp, err := c.DeleteMonitoringData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMonitoringDataResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// GetRuleDetailsWithResponse request returning *GetRuleDetailsResponse
func (c *ClientWithResponses) GetRuleDetailsWithResponse(ctx context.Context, params *GetRuleDetailsParams, reqEditors ...RequestEditorFn) (*GetRuleDetailsResponse, error) {
	rsp, err := c.GetRuleDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleDetailsResponse(rsp)
}

// GetSanctionAlertsWithBodyWithResponse request with arbitrary body returning *GetSanctionAlertsResponse
func (c *ClientWithResponses) GetSanctionAlertsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSanctionAlertsResponse, error) {
	rsp, err := c.GetSanctionAlertsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSanctionAlertsResponse(rsp)
}

func (c *ClientWithResponses) GetSanctionAlertsWithResponse(ctx context.Context, body GetSanctionAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSanctionAlertsResponse, error) {
	rsp, err := c.GetSanctionAlerts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSanctionAlertsResponse(rsp)
}

// NewSubaccountWithBodyWithResponse request with arbitrary body returning *NewSubaccountResponse
func (c *ClientWithResponses) NewSubaccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSubaccountResponse, error) {
	rsp, err := c.NewSubaccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSubaccountResponse(rsp)
}

func (c *ClientWithResponses) NewSubaccountWithResponse(ctx context.Context, body NewSubaccountJSONRequestBody, reqEditors ...RequestEditorFn) (*NewSubaccountResponse, error) {
	rsp, err := c.NewSubaccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSubaccountResponse(rsp)
}

// NewSubaccount1WithBodyWithResponse request with arbitrary body returning *NewSubaccount1Response
func (c *ClientWithResponses) NewSubaccount1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewSubaccount1Response, error) {
	rsp, err := c.NewSubaccount1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSubaccount1Response(rsp)
}

func (c *ClientWithResponses) NewSubaccount1WithResponse(ctx context.Context, body NewSubaccount1JSONRequestBody, reqEditors ...RequestEditorFn) (*NewSubaccount1Response, error) {
	rsp, err := c.NewSubaccount1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewSubaccount1Response(rsp)
}

// V2DevicesWithBodyWithResponse request with arbitrary body returning *V2DevicesResponse
func (c *ClientWithResponses) V2DevicesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V2DevicesResponse, error) {
	rsp, err := c.V2DevicesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV2DevicesResponse(rsp)
}

func (c *ClientWithResponses) V2DevicesWithResponse(ctx context.Context, body V2DevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*V2DevicesResponse, error) {
	rsp, err := c.V2Devices(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV2DevicesResponse(rsp)
}

// ParsePostPlaidProcessorTokenResponse parses an HTTP response from a PostPlaidProcessorTokenWithResponse call
func ParsePostPlaidProcessorTokenResponse(rsp *http.Response) (*PostPlaidProcessorTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPlaidProcessorTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Successful requst message
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Status Invalid request message
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			// Status Duplicate request message
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Message Failed request message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePlaidDataSyncResponse parses an HTTP response from a PlaidDataSyncWithResponse call
func ParsePlaidDataSyncResponse(rsp *http.Response) (*PlaidDataSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlaidDataSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Successful requst message
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// PlaidError Error details provided by Plaid
			PlaidError *struct {
				// DisplayMessage A user-friendly representation of the error code. null if the error is not related to user action.
				DisplayMessage *string `json:"display_message,omitempty"`

				// ErrorCode The particular error code. Safe for programmatic use.
				ErrorCode *string `json:"error_code,omitempty"`

				// ErrorMessage A developer-friendly representation of the error code. This may change over time and is not safe for programmatic use.
				ErrorMessage *string `json:"error_message,omitempty"`

				// ErrorType A broad categorization of the error. Safe for programmatic use.
				ErrorType *string `json:"error_type,omitempty"`

				// RequestId A unique ID identifying the request, to be used for troubleshooting purposes.
				RequestId *string `json:"request_id,omitempty"`
			} `json:"plaidError,omitempty"`

			// Status Invalid request message
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Message Failed request message
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllowlistClientResponse parses an HTTP response from a GetAllowlistClientWithResponse call
func ParseGetAllowlistClientResponse(rsp *http.Response) (*GetAllowlistClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllowlistClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ClientId Account client ID of allowlist where item was added
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the allowlist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the allowlisting request
				Reason *GetAllowlistClient200DataReason `json:"reason,omitempty"`

				// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
				RuleIds *[]int                          `json:"ruleIds,omitempty"`
				Scope   *GetAllowlistClient200DataScope `json:"scope,omitempty"`
				Type    *GetAllowlistClient200DataType  `json:"type,omitempty"`

				// Value The value of the allowlisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAllowListCreateResponse parses an HTTP response from a PostAllowListCreateWithResponse call
func ParsePostAllowListCreateResponse(rsp *http.Response) (*PostAllowListCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAllowListCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ClientId Account client ID of allowlist where item was added
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the allowlist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the allowlisting request
				Reason *PostAllowListCreate200DataReason `json:"reason,omitempty"`

				// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
				RuleIds *[]int                           `json:"ruleIds,omitempty"`
				Scope   *PostAllowListCreate200DataScope `json:"scope,omitempty"`
				Type    *PostAllowListCreate200DataType  `json:"type,omitempty"`

				// Value The value of the allowlisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAllowlistExpireResponse parses an HTTP response from a PostAllowlistExpireWithResponse call
func ParsePostAllowlistExpireResponse(rsp *http.Response) (*PostAllowlistExpireResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAllowlistExpireResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ClientId Account client ID of allowlist where item was added
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the allowlist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the allowlisting request
				Reason *PostAllowlistExpire200DataReason `json:"reason,omitempty"`

				// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
				RuleIds *[]int                           `json:"ruleIds,omitempty"`
				Scope   *PostAllowlistExpire200DataScope `json:"scope,omitempty"`
				Type    *PostAllowlistExpire200DataType  `json:"type,omitempty"`

				// Value The value of the allowlisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAllowlistFindResponse parses an HTTP response from a PostAllowlistFindWithResponse call
func ParsePostAllowlistFindResponse(rsp *http.Response) (*PostAllowlistFindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAllowlistFindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ClientId Account client ID of allowlist where item was added
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the allowlist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the allowlist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the allowlisting request
				Reason *PostAllowlistFind200DataReason `json:"reason,omitempty"`

				// RuleIds List of rule IDs that allowlisting is restricted to. If none are provided, the allowlisted item applies to all rules.
				RuleIds *[]int                         `json:"ruleIds,omitempty"`
				Scope   *PostAllowlistFind200DataScope `json:"scope,omitempty"`
				Type    *PostAllowlistFind200DataType  `json:"type,omitempty"`

				// Value The value of the allowlisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostBankTransactionsResponse parses an HTTP response from a PostBankTransactionsWithResponse call
func ParsePostBankTransactionsResponse(rsp *http.Response) (*PostBankTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBankTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SessionKey unique identifier for the given customer session on your platform, generated by your service. We expect it to be short-lived (e.g. expires after 30 min)
			SessionKey *string `json:"sessionKey,omitempty"`

			// Status always returns "Success" for successful response
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClientBlocklistsResponse parses an HTTP response from a GetClientBlocklistsWithResponse call
func ParseGetClientBlocklistsResponse(rsp *http.Response) (*GetClientBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the blocklist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the blocklisting request.
				Reason *GetClientBlocklists200DataReason `json:"reason,omitempty"`
				Scope  *GetClientBlocklists200DataScope  `json:"scope,omitempty"`

				// Type The type of item to be blocklisted.
				Type *GetClientBlocklists200DataType `json:"type,omitempty"`

				// Value The value of the blocklisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostClientBlocklistsResponse parses an HTTP response from a PostClientBlocklistsWithResponse call
func ParsePostClientBlocklistsResponse(rsp *http.Response) (*PostClientBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClientBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the blocklist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the blocklisting request.
				Reason *PostClientBlocklists200DataReason `json:"reason,omitempty"`
				Scope  *PostClientBlocklists200DataScope  `json:"scope,omitempty"`

				// Type The type of item to be blocklisted.
				Type *PostClientBlocklists200DataType `json:"type,omitempty"`

				// Value The value of the blocklisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostBlockListExpireResponse parses an HTTP response from a PostBlockListExpireWithResponse call
func ParsePostBlockListExpireResponse(rsp *http.Response) (*PostBlockListExpireResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBlockListExpireResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the blocklist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the blocklisting request.
				Reason *PostBlockListExpire200DataReason `json:"reason,omitempty"`
				Scope  *PostBlockListExpire200DataScope  `json:"scope,omitempty"`

				// Type The type of item to be blocklisted.
				Type *PostBlockListExpire200DataType `json:"type,omitempty"`

				// Value The value of the blocklisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostSpecificBlockListResponse parses an HTTP response from a PostSpecificBlockListWithResponse call
func ParsePostSpecificBlockListResponse(rsp *http.Response) (*PostSpecificBlockListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSpecificBlockListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ClientId Account client ID of allowlist where item was added. If string does not match the authorized client id it will be changed to authorized client id
				ClientId *string `json:"client_id,omitempty"`

				// Comment Optional comment provided when item was added to the blocklist.
				Comment *string `json:"comment,omitempty"`

				// Expiry This field is a unix timestamp which tells when this user expires from the blocklist.
				Expiry *float32 `json:"expiry,omitempty"`
				Id     *float32 `json:"id,omitempty"`

				// Reason Source of the blocklisting request.
				Reason *PostSpecificBlockList200DataReason `json:"reason,omitempty"`
				Scope  *PostSpecificBlockList200DataScope  `json:"scope,omitempty"`

				// Type The type of item to be blocklisted.
				Type *PostSpecificBlockList200DataType `json:"type,omitempty"`

				// Value The value of the blocklisted item.
				Value *string `json:"value,omitempty"`
			} `json:"data,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetbixResponse parses an HTTP response from a GetbixWithResponse call
func ParseGetbixResponse(rsp *http.Response) (*GetbixResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetbixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ClientID Unique identifier for your Sardine account this KYB check was run on
			ClientID *string               `json:"clientID,omitempty"`
			Config   *BizConfigGetResponse `json:"config,omitempty"`

			// CustomerIds List of business owners' customer IDs
			CustomerIds *[]string `json:"customerIds,omitempty"`

			// Id The Sardine specific identifier
			Id  *int32 `json:"id,omitempty"`
			Kyb *struct {
				Address        *[]BizAddress `json:"address,omitempty"`
				Alias          *[]string     `json:"alias,omitempty"`
				FormationState *string       `json:"formationState,omitempty"`
				Tasks          *[]struct {
					Category *string `json:"category,omitempty"`
					Label    *string `json:"label,omitempty"`
					Message  *string `json:"message,omitempty"`
					Name     *string `json:"name,omitempty"`
					Sources  *[]struct {
						Metadata *struct {
							Name      *string `json:"name,omitempty"`
							Submitted *bool   `json:"submitted,omitempty"`
						} `json:"metadata,omitempty"`
						Type *string `json:"type,omitempty"`
					} `json:"sources,omitempty"`
					Status   *string `json:"status,omitempty"`
					SubLabel *string `json:"subLabel,omitempty"`
					Type     *string `json:"type,omitempty"`
				} `json:"tasks,omitempty"`
			} `json:"kyb,omitempty"`

			// Name Name of the business
			Name *string `json:"name,omitempty"`

			// RuleExecutedAt Timestamp in milliseconds when the business verification rules were executed
			RuleExecutedAt *int64 `json:"ruleExecutedAt,omitempty"`

			// RuleMatched List of business rules that triggered on this business verification
			RuleMatched *[]int64 `json:"ruleMatched,omitempty"`

			// RuleNotMatched List of business rules that did not triggered on this business verification
			RuleNotMatched *[]int64 `json:"ruleNotMatched,omitempty"`

			// Status Status of the business verification
			Status *Getbix200Status `json:"status,omitempty"`

			// TrackingId Your unique identifier for this business
			TrackingId *string `json:"trackingId,omitempty"`

			// UpdatedAt Timestamp in milliseconds when the business verification was last updated
			UpdatedAt *int64 `json:"updatedAt,omitempty"`

			// Website Website of the business
			Website *string `json:"website,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Reason Reason for failed API request
			Reason *string `json:"reason,omitempty"`

			// Status Status of the authentication request
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Details on reason for error message
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateBizResponse parses an HTTP response from a UpdateBizWithResponse call
func ParseUpdateBizResponse(rsp *http.Response) (*UpdateBizResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBizResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SardineID The Sardine specific identifier
			SardineID *string `json:"sardineID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Invalid API input error details message
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Reason Reason for failed API request
			Reason *string `json:"reason,omitempty"`

			// Status Status of the authentication request
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 424:
		var dest struct {
			// Error Details on reason for error message
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON424 = &dest

	}

	return response, nil
}

// ParseAddUpdateBizResponse parses an HTTP response from a AddUpdateBizWithResponse call
func ParseAddUpdateBizResponse(rsp *http.Response) (*AddUpdateBizResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUpdateBizResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmlEntities This object is only avaliable if you use advancedAmlScreening in synchronous mode.
			AmlEntities *[]struct {
				AdverseMedia *struct {
					// Level Adverse media level
					Level   *AddUpdateBiz200AmlEntitiesAdverseMediaLevel `json:"level,omitempty"`
					Sources *[]struct {
						// Category Category of the adverse media
						Category *string `json:"category,omitempty"`

						// Description Description of the adverse media
						Description *string `json:"description,omitempty"`

						// SourceName Name of the adverse media source
						SourceName *string `json:"sourceName,omitempty"`

						// SourceUrl URL to the source of the adverse media
						SourceUrl *string `json:"sourceUrl,omitempty"`

						// SubCategory Sub-category of the adverse media
						SubCategory *string `json:"subCategory,omitempty"`
					} `json:"sources,omitempty"`
				} `json:"adverseMedia,omitempty"`
				CountryCodes *[]string `json:"countryCodes,omitempty"`

				// EntityName Name of the entity
				EntityName *string `json:"entityName,omitempty"`

				// MatchScore Match score indicating the likelihood of a match (0-100 with 100 highest match)
				MatchScore *int `json:"matchScore,omitempty"`
				Pep        *struct {
					// Level Pep level
					Level   *AddUpdateBiz200AmlEntitiesPepLevel `json:"level,omitempty"`
					Sources *[]struct {
						// Description Description of the Pep
						Description *string `json:"description,omitempty"`

						// SourceName Name of the Pep source
						SourceName *string `json:"sourceName,omitempty"`

						// SourceUrl URL to the source of the Pep
						SourceUrl *string `json:"sourceUrl,omitempty"`
					} `json:"sources,omitempty"`
				} `json:"pep,omitempty"`

				// RiskLevel Risk level associated with the entity
				RiskLevel *AddUpdateBiz200AmlEntitiesRiskLevel `json:"riskLevel,omitempty"`

				// RiskScore Risk score associated with the entity (0-100 with 100 highest risk)
				RiskScore *int `json:"riskScore,omitempty"`
				Sanction  *struct {
					// Level Sanction level
					Level   *AddUpdateBiz200AmlEntitiesSanctionLevel `json:"level,omitempty"`
					Sources *[]struct {
						// Description Description of the sanction
						Description *string `json:"description,omitempty"`

						// SourceName Name of the sanction source
						SourceName *string `json:"sourceName,omitempty"`

						// SourceUrl URL to the source of the sanction
						SourceUrl *string `json:"sourceUrl,omitempty"`
					} `json:"sources,omitempty"`
				} `json:"sanction,omitempty"`
			} `json:"amlEntities,omitempty"`

			// SardineID The Sardine specific identifier
			SardineID *string `json:"sardineID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Invalid API input error details message
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Reason Reason for failed API request
			Reason *string `json:"reason,omitempty"`

			// Status Status of the authentication request
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Details on reason for error message
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostV1BusinessesScreeningPmsResponse parses an HTTP response from a PostV1BusinessesScreeningPmsWithResponse call
func ParsePostV1BusinessesScreeningPmsResponse(rsp *http.Response) (*PostV1BusinessesScreeningPmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV1BusinessesScreeningPmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor Cursor for the next page of results
			NextCursor *int `json:"nextCursor,omitempty"`
			Results    *[]struct {
				// AmlEntities This object is only avaliable if you use advancedAmlScreening in synchronous mode.
				AmlEntities *BizAmlEntities `json:"amlEntities,omitempty"`

				// SardineID Unique Sardine identifier for the business
				SardineID *int `json:"sardineID,omitempty"`

				// TrackingID Unique identifier as defined by you in the original screening request
				TrackingID *string `json:"trackingID,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCaseResponse parses an HTTP response from a GetCaseWithResponse call
func ParseGetCaseResponse(rsp *http.Response) (*GetCaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AssignedTo Sardine dashboard user the case has been assigned to
			AssignedTo *string `json:"assignedTo,omitempty"`

			// CaseDecision Latest decision of the case
			CaseDecision *string `json:"caseDecision,omitempty"`

			// CaseDecisionLabelId Sardine identifier for the decision value
			CaseDecisionLabelId *string `json:"caseDecisionLabelId,omitempty"`

			// CaseDescription Description of the case
			CaseDescription *string `json:"caseDescription,omitempty"`

			// CaseName Name assigned to case
			CaseName *string `json:"caseName,omitempty"`

			// CaseStatus Latest status of the case
			CaseStatus *GetCase200CaseStatus `json:"caseStatus,omitempty"`

			// ClientID Sardine account identifier the case belongs to
			ClientID *string `json:"clientID,omitempty"`

			// ContinuingReportTimer Timestamp when case continuing report timer
			ContinuingReportTimer *int64 `json:"continuingReportTimer,omitempty"`

			// CreatedAt Timestamp when case was created
			CreatedAt *int64 `json:"createdAt,omitempty"`

			// Documents Details of files uploaded to the case
			Documents *[]struct {
				// DocumentID Sardine identifier for the uploaded file
				DocumentID *string `json:"documentID,omitempty"`

				// DocumentName Name of the uploaded file
				DocumentName *string `json:"documentName,omitempty"`

				// DocumentPath Path to access the uploaded file
				DocumentPath *string `json:"documentPath,omitempty"`
			} `json:"documents,omitempty"`

			// ExtensionTimer Timestamp when case extension timer
			ExtensionTimer *int64 `json:"extensionTimer,omitempty"`

			// Id Sardine case identifier
			Id *int64 `json:"id,omitempty"`

			// InitialTimer Timestamp when case initial timer
			InitialTimer *int64 `json:"initialTimer,omitempty"`

			// LinkedBusinesses List of business IDs this case is linked to
			LinkedBusinesses *[]string `json:"linkedBusinesses,omitempty"`

			// LinkedCustomer List of customer IDs this case is linked to
			LinkedCustomer *[]string `json:"linkedCustomer,omitempty"`

			// LinkedReviews List of review IDs this case is linked to
			LinkedReviews *[]string `json:"linkedReviews,omitempty"`

			// LinkedTransaction List of transaction IDs this case is linked to
			LinkedTransaction *[]string `json:"linkedTransaction,omitempty"`

			// UpdatedAt Timestamp when case was last updated
			UpdatedAt *int64 `json:"updatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewCaseResponse parses an HTTP response from a NewCaseWithResponse call
func ParseNewCaseResponse(rsp *http.Response) (*NewCaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewCaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CaseID Sardine identifier for the case
			CaseID *string `json:"caseID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCaseResponse parses an HTTP response from a UpdateCaseWithResponse call
func ParseUpdateCaseResponse(rsp *http.Response) (*UpdateCaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CaseID Sardine identifier for the case
			CaseID *string `json:"caseID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomListResponse parses an HTTP response from a PostCustomListWithResponse call
func ParsePostCustomListResponse(rsp *http.Response) (*PostCustomListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ClientList `json:"data,omitempty"`

			// Message Status message for the custom list request.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomListDeleteResponse parses an HTTP response from a PostCustomListDeleteWithResponse call
func ParsePostCustomListDeleteResponse(rsp *http.Response) (*PostCustomListDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomListDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Status of the deletion request.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostNewListItemsResponse parses an HTTP response from a PostNewListItemsWithResponse call
func ParsePostNewListItemsResponse(rsp *http.Response) (*PostNewListItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNewListItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Status of the deletion request.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostItemsDeleteResponse parses an HTTP response from a PostItemsDeleteWithResponse call
func ParsePostItemsDeleteResponse(rsp *http.Response) (*PostItemsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostItemsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status Status of the deletion request.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomListRetrieveResponse parses an HTTP response from a GetCustomListRetrieveWithResponse call
func ParseGetCustomListRetrieveResponse(rsp *http.Response) (*GetCustomListRetrieveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomListRetrieveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ClientList `json:"data,omitempty"`

			// Message Status message for the custom list request.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomerInformationResponse parses an HTTP response from a PostCustomerInformationWithResponse call
func ParsePostCustomerInformationResponse(rsp *http.Response) (*PostCustomerInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CheckpointData List of checkpoints run for this session
			CheckpointData *CheckpointDataResponse `json:"checkpointData,omitempty"`

			// Checkpoints Result of rule evaluations for each checkpoint. `customer` checkpoint is executed by default.
			Checkpoints  *CheckPointsResponse `json:"checkpoints,omitempty"`
			Counterparty *struct {
				AmlEntities   *[]AmlEntity `json:"amlEntities,omitempty"`
				PaymentMethod *struct {
					AmlEntities *[]AmlEntity `json:"amlEntities,omitempty"`
				} `json:"paymentMethod,omitempty"`
			} `json:"counterparty,omitempty"`

			// Customer customer riskiness level and associated signals
			Customer *CustomerResponse `json:"customer,omitempty"`

			// Device Device riskiness level and associated signals
			Device *DevicesResponse `json:"device,omitempty"`

			// Level Risk at overall level: "very_high", "high", "medium", "low". This is the top-level field that you can use to make a risk decision. It is max of customer.level and device.level
			Level *string `json:"level,omitempty"`

			// Rules List of live and shadow rules that triggered for this session
			Rules *RulesResponse `json:"rules,omitempty"`

			// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
			SessionKey *string `json:"sessionKey,omitempty"`

			// Status status of the API response
			Status *PostCustomerInformation200Status `json:"status,omitempty"`

			// Transaction transaction related information
			Transaction *TransactionResponse `json:"transaction,omitempty"`

			// Workflow workflow excecution output data if a workflowName was provided in the request
			Workflow *WorkflowResponse `json:"workflow,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Message Details on reason for API error
			Message *string `json:"message,omitempty"`

			// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
			SessionKey *string `json:"sessionKey,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Reason Details on reason for API error
			Reason *string `json:"reason,omitempty"`

			// Status status of the API response
			Status *PostCustomerInformation401Status `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			// Message Details on reason for API error
			Message *string `json:"message,omitempty"`

			// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
			SessionKey *string `json:"sessionKey,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePostCustomersDeletionsResponse parses an HTTP response from a PostCustomersDeletionsWithResponse call
func ParsePostCustomersDeletionsResponse(rsp *http.Response) (*PostCustomersDeletionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersDeletionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostDocumentUploadResponse parses an HTTP response from a PostDocumentUploadWithResponse call
func ParsePostDocumentUploadResponse(rsp *http.Response) (*PostDocumentUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDocumentUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FileResults *[]struct {
				DocumentId *string `json:"document_id,omitempty"`
				Tag        *string `json:"tag,omitempty"`
			} `json:"file_results,omitempty"`

			// Status Status of the upload request.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomerFeedbackResponse parses an HTTP response from a PostCustomerFeedbackWithResponse call
func ParsePostCustomerFeedbackResponse(rsp *http.Response) (*PostCustomerFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Status always returns "success" for successful response
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostKycTokenResponse parses an HTTP response from a PostKycTokenWithResponse call
func ParsePostKycTokenResponse(rsp *http.Response) (*PostKycTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostKycTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken jwt token for the process
			AccessToken *string `json:"access_token,omitempty"`

			// ExpiresIn Expiry of the token
			ExpiresIn *int `json:"expires_in,omitempty"`

			// IncodeSdkBaseUrl base url to initialized Incode SDK.
			IncodeSdkBaseUrl *string `json:"incode_sdk_base_url,omitempty"`

			// Scope scope of the token to be used.
			Scope *string `json:"scope,omitempty"`

			// TokenType type of the token
			TokenType *string `json:"token_type,omitempty"`

			// VerificationId verification id of the session
			VerificationId *string `json:"verification_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostKycDocumentsResponse parses an HTTP response from a PostKycDocumentsWithResponse call
func ParsePostKycDocumentsResponse(rsp *http.Response) (*PostKycDocumentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostKycDocumentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id id of the document kyc process
			Id   *string `json:"id,omitempty"`
			Link *struct {
				// ExpiredAt Expiry of the url
				ExpiredAt *string `json:"expiredAt,omitempty"`

				// Url Url to perform doc kyc
				Url *string `json:"url,omitempty"`
			} `json:"link,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostIdentityDocumentImagesResponse parses an HTTP response from a PostIdentityDocumentImagesWithResponse call
func ParsePostIdentityDocumentImagesResponse(rsp *http.Response) (*PostIdentityDocumentImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostIdentityDocumentImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Back base64 string of the back of the ID document associated with the verificationId (if collected)
			Back *string `json:"back,omitempty"`

			// Front base64 string of the back of the ID document associated with the verificationId (if collected)
			Front *string `json:"front,omitempty"`

			// Selfie base64 string of the selfie image associated with the verificationId (if collected)
			Selfie *string `json:"selfie,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIdentityDocumentResponse parses an HTTP response from a GetIdentityDocumentWithResponse call
func ParseGetIdentityDocumentResponse(rsp *http.Response) (*GetIdentityDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DocumentData data extracted from the document
			DocumentData *struct {
				// Address address written on the document
				Address *string `json:"address,omitempty"`

				// DateOfBirth date of birth, returned as YYYY-MM-DD format
				DateOfBirth *string `json:"dateOfBirth,omitempty"`

				// DateOfExpiry date of document expiration
				DateOfExpiry *string `json:"dateOfExpiry,omitempty"`

				// DateOfIssue date of document issued
				DateOfIssue *string `json:"dateOfIssue,omitempty"`

				// FirstName first name
				FirstName *string `json:"firstName,omitempty"`

				// Gender male, female, or other
				Gender *string `json:"gender,omitempty"`

				// IssuingCountry issuing country, in 2-digit ISO code
				IssuingCountry *string `json:"issuingCountry,omitempty"`

				// LastName last name
				LastName *string `json:"lastName,omitempty"`

				// MiddleName middle name
				MiddleName *string `json:"middleName,omitempty"`

				// Number number of the document
				Number *string `json:"number,omitempty"`

				// Type type of ID document: `Unknown`,  `Passport`, `Visa`, `DriversLicense`, `IdentificationCard`, `Permit` , `ResidenceDocument` ,  `TravelDocument` , `BirthCertificate` ,  `VehicleRegistration` , `Other` ,  `WeaponLicense` ,  `TribalIdentification` ,  `VoterIdentification` , and `Military`
				Type *string `json:"type,omitempty"`
			} `json:"documentData,omitempty"`

			// ErrorCodes reason for processing error.
			//
			// | Code | Description |
			// |------|---------|
			// | unrecognizable_document  | Document could not be recognized, please resubmit with higher resolution image |
			// | requires_recapture  | Provided document requires recapturing |
			// | document_bad_size_or_type  | Either file size or type of provided document is not supported |
			ErrorCodes *[]string `json:"errorCodes,omitempty"`

			// Status Status of the verification. One of `pending`, `processing`, `complete` and `error`. When `error`, `errorCode` field below explains the reason for error.
			Status       string `json:"status"`
			Verification *struct {
				// DocumentMatchLevel likelihood of inputData match with the document image. `high`, `medium`, `low`, or `not_applicable`
				DocumentMatchLevel *string `json:"documentMatchLevel,omitempty"`

				// FaceMatchLevel likelihood of photo/selfie match with the document image. `high`, `medium`, `low`, `not_applicable`, or `error`
				FaceMatchLevel *string `json:"faceMatchLevel,omitempty"`

				// ForgeryLevel Indicates the likelihood of submitted document is forged. `high`, `medium`, `low`, or `unknown` The forgery level is based on a variety of checks around the integrity of the document. An `unknown` level indicates Sardine was not able to evaluate the document (e.g. non-support document type, non-successful capture of the document/selfie)
				ForgeryLevel *string `json:"forgeryLevel,omitempty"`

				// ImageQualityLevel image quality of ID document. `high`, `medium`, `low`
				ImageQualityLevel *string `json:"imageQualityLevel,omitempty"`

				// RiskLevel Overall riskiness of accepting this ID document. `high`, `medium`, `low`, or `unknown` The overall risk level of a document verification is determined by Machine Learning (ML) model tests, as well as the other individual ID tests (e.g. document crosscheck, expiration date validity, etc.). An `unknown` level indicates Sardine was not able to evaluate the document (e.g. non-support document type, non-successful capture of the document/selfie).
				RiskLevel *string `json:"riskLevel,omitempty"`
			} `json:"verification,omitempty"`

			// VerificationId ID of document verification
			VerificationId string `json:"verificationId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCardsAuthorizationsResponse parses an HTTP response from a PostCardsAuthorizationsWithResponse call
func ParsePostCardsAuthorizationsResponse(rsp *http.Response) (*PostCardsAuthorizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCardsAuthorizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmlLevel AML risk level like high, medium and low.
			AmlLevel *string `json:"amlLevel,omitempty"`

			// Checkpoints Result of rule evaluations for each checkpoint. `issuingrisk` checkpoint is executed by default.
			Checkpoints *CheckPointsResponseIssuing `json:"checkpoints,omitempty"`

			// Level Risk level like very_high, high, medium and low
			Level *string `json:"level,omitempty"`

			// ReasonCodes List of reason codes returned for this session (it is omitted if empty). Example: ALWR
			ReasonCodes *[]string `json:"reasonCodes,omitempty"`

			// Rules List of live and shadow rules that triggered for this session
			Rules *RulesResponse `json:"rules,omitempty"`

			// Score ML Risk Score for this particular transaction. The ML model used to predict the score is trained on various features and can be used once sufficient data and feedback have been provided.
			Score *float32 `json:"score,omitempty"`

			// SessionKey Unique identifier for the given customer session as provided by you in the API request payload
			SessionKey *string `json:"sessionKey,omitempty"`

			// Status Status of the API response
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMonitoringDataResponse parses an HTTP response from a DeleteMonitoringDataWithResponse call
func ParseDeleteMonitoringDataResponse(rsp *http.Response) (*DeleteMonitoringDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMonitoringDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Rules *[]Rules `json:"rules,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleDetailsResponse parses an HTTP response from a GetRuleDetailsWithResponse call
func ParseGetRuleDetailsResponse(rsp *http.Response) (*GetRuleDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSanctionAlertsResponse parses an HTTP response from a GetSanctionAlertsWithResponse call
func ParseGetSanctionAlertsResponse(rsp *http.Response) (*GetSanctionAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSanctionAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor cursor for the next page
			NextCursor *string `json:"nextCursor,omitempty"`

			// Results if the results are null or empty you have no more results
			Results *[]struct {
				Aml *struct {
					AdverseMedia *[]AmlObject `json:"adverseMedia,omitempty"`
					Alias        *[]string    `json:"alias,omitempty"`
					CountryCodes *[]string    `json:"countryCodes,omitempty"`
					DateOfBirths *[]string    `json:"dateOfBirths,omitempty"`
					EntityName   *string      `json:"entityName,omitempty"`

					// MatchScore possible score 0 to 100 higher the better. represents how close the entity match the given data
					MatchScore *int         `json:"matchScore,omitempty"`
					Pep        *[]AmlObject `json:"pep,omitempty"`

					// RiskScore possible score 0 to 100 higher the better. represents how risky a entity is.
					RiskScore *int         `json:"riskScore,omitempty"`
					Sanction  *[]AmlObject `json:"sanction,omitempty"`
				} `json:"aml,omitempty"`

				// Signals | Name | Description |Values|
				// |--------|---------|------------
				// | sanctionLevel | Check if the customer belongs to sanction list like SDN/OFAC. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
				// | pepLevel | Check if the customer belongs to PEP(Politically Exposed Person) list. Only available, if Sanctions Screening is enabled for your account.|high/medium/low|
				// | adverseMediaLevel | Check if the customer has any associated adverse media . Only available if Sanctions Screening is enabled for your account.|high/medium/low|
				Signals *[]Signal `json:"signals,omitempty"`

				// UserIdHash user id hash, as provided by you in customers API
				UserIdHash *string `json:"userIdHash,omitempty"`
			} `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewSubaccountResponse parses an HTTP response from a NewSubaccountWithResponse call
func ParseNewSubaccountResponse(rsp *http.Response) (*NewSubaccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewSubaccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id ID of newly generated subaccount
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewSubaccount1Response parses an HTTP response from a NewSubaccount1WithResponse call
func ParseNewSubaccount1Response(rsp *http.Response) (*NewSubaccount1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewSubaccount1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Secret generated secret for this subaccount
			Secret *string `json:"secret,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseV2DevicesResponse parses an HTTP response from a V2DevicesWithResponse call
func ParseV2DevicesResponse(rsp *http.Response) (*V2DevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V2DevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
